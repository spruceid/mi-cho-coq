(* generated by Ott 0.28 from: michelson.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import ZArith.
Require Import String.

Require Import List.
Import ListNotations.


Inductive ctype : Set := 
 | ct_Int : ctype
 | ct_Nat : ctype
 | ct_String : ctype
 | ct_Bool : ctype.

Inductive type : Set := 
 | t_Ct (ct:ctype)
 | t_Key : type
 | t_Unit : type
 | t_Signature : type
 | t_Option (t:string)
 | t_List (t:string)
 | t_Set (ct:ctype)
 | t_Operation : type
 | t_Contract (t:string)
 | t_Pair (t:string) (t':string)
 | t_Or (t:string) (t':string)
 | t_Lambda (t:string) (t':string)
 | t_Map (ct:ctype) (t:string)
 | t_Big (ct:ctype) (t:string).

Inductive num : Set := 
 | N_IntConstant (z:Z)
 | N_NatConstant (n:nat).

Inductive data : Set := 
 | d_Num (N:num)
 | d_StringConstant (s:string)
 | d_Unit : data
 | d_BoolConstant (b:bool)
 | d_Pair (d:data) (d':data)
 | d_Left (d:data)
 | d_Right (d:data)
 | d_Some (d:data)
 | d_None : data
 | d_DataList (dl:list data)
 | d_Set (set5:list data)
 | d_Map (map5:list (data * data))
 | d_Instruction (instruction5:instruction)
with instruction : Set := 
 | i_Seq (i:instruction) (i':instruction)
 | i_Drop : instruction
 | i_Dup : instruction
 | i_Swap : instruction
 | i_Push (ty:type) (d:data)
 | i_Some : instruction
 | i_None (ty:type)
 | i_Unit : instruction
 | i_IfNone (i:instruction) (i':instruction)
 | i_Pair : instruction
 | i_Car : instruction
 | i_Cdr : instruction
 | i_Left (ty:type)
 | i_Right (ty:type)
 | i_IfLeft (i:instruction) (i':instruction)
 | i_IfRight (i:instruction) (i':instruction)
 | i_Nil (ty:type)
 | i_Cons : instruction
 | i_IfCons (i:instruction) (i':instruction)
 | i_EmptySet (ty:type)
 | i_EmptyMap (ct:ctype) (ty:type)
 | i_Map (i:instruction)
 | i_Iter (i:instruction)
 | i_Mem : instruction
 | i_Get : instruction
 | i_Update : instruction
 | i_If (i:instruction) (i':instruction)
 | i_Loop (i:instruction)
 | i_LoopLeft (i:instruction)
 | i_Lambda (ty:type) (ty':type) (i:instruction)
 | i_Exec : instruction
 | i_Dip (i:instruction)
 | i_Failwith : instruction
 | i_Cast : instruction
 | i_Rename : instruction
 | i_Concat : instruction
 | i_Add : instruction
 | i_Sub : instruction
 | i_Mul : instruction
 | i_Div : instruction
 | i_EDiv : instruction
 | i_Abs : instruction
 | i_Neg : instruction
 | i_Mod : instruction
 | i_Lsl : instruction
 | i_Lsr : instruction
 | i_Or : instruction
 | i_And : instruction
 | i_Xor : instruction
 | i_Not : instruction
 | i_Compare : instruction
 | i_Size : instruction
 | i_Slice : instruction
 | i_Eq : instruction
 | i_Neq : instruction
 | i_Lt : instruction
 | i_Gt : instruction
 | i_Le : instruction
 | i_Ge : instruction
 | i_Int : instruction
 | i_Self : instruction
 | i_Transfer : instruction
 | i_Set : instruction
 | i_CreateAccount : instruction
 | i_CreateContract : instruction
 | i_Implicit : instruction
 | i_Now : instruction
 | i_Amount : instruction
 | i_Balance : instruction
 | i_Check : instruction
 | i_Blake2b : instruction
 | i_Hash : instruction
 | i_Steps : instruction
 | i_Source : instruction
 | i_Sender : instruction.

Inductive stackerr : Set := 
 | SE_Failed : stackerr
 | SE_Stack (stack5:list data).

Inductive aop : Set := 
 | aop_Add : aop
 | aop_Sub : aop
 | aop_Mul : aop
 | aop_Div : aop
 | aop_Mod : aop
 | aop_Lsl : aop
 | aop_Lsr : aop.

Inductive bitop : Set := 
 | bitop_Or : bitop
 | bitop_And : bitop
 | bitop_Xor : bitop.

Load Formulas.

(** definitions *)

(* defns Op *)
Inductive BigStep : instruction -> stackerr -> stackerr -> Prop :=    (* defn BigStep *)
 | bs_failwith : forall (d:data) (stack5:list data),
     BigStep i_Failwith (SE_Stack  ( d  ::  stack5 ) ) SE_Failed
 | bs_failed : forall (i:instruction),
     BigStep i SE_Failed SE_Failed
 | bs_sequence : forall (i1 i2:instruction) (S:list data) (SE' SE'':stackerr),
     BigStep i1 (SE_Stack S) SE'' ->
     BigStep i2 SE'' SE' ->
     BigStep (i_Seq i1 i2) (SE_Stack S) SE'
 | bs_if_tt : forall (i1 i2:instruction) (S S':list data),
     BigStep i1 (SE_Stack S) (SE_Stack S') ->
     BigStep (i_If i1 i2) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) ) (SE_Stack S')
 | bs_if_ff : forall (i1 i2:instruction) (S S':list data),
     BigStep i2 (SE_Stack S) (SE_Stack S') ->
     BigStep (i_If i1 i2) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) ) (SE_Stack S')
 | bs_loop_tt : forall (i1:instruction) (S S':list data),
     BigStep (i_Seq i1 (i_Loop i1)) (SE_Stack S) (SE_Stack S') ->
     BigStep (i_Loop i1) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) ) (SE_Stack S')
 | bs_loop_ff : forall (i1:instruction) (S:list data),
     BigStep (i_Loop i1) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) ) (SE_Stack S)
 | bs_loop_left_tt : forall (i1:instruction) (d:data) (S S':list data),
     BigStep (i_Seq i1 (i_LoopLeft i1)) (SE_Stack  ( d  ::  S ) ) (SE_Stack S') ->
     BigStep (i_LoopLeft i1) (SE_Stack  ( (d_Left d)  ::  S ) ) (SE_Stack S')
 | bs_dip : forall (i1:instruction) (d:data) (S S':list data),
     BigStep i1 (SE_Stack S) (SE_Stack S') ->
     BigStep (i_Dip i1) (SE_Stack  ( d  ::  S ) ) (SE_Stack  ( d  ::  S' ) )
 | bs_exec : forall (i:instruction) (d2:data) (S:list data) (d3:data),
     BigStep i (SE_Stack  ( d2  ::   []  ) ) (SE_Stack  ( d3  ::   []  ) ) ->
     BigStep i_Exec (SE_Stack  ( (d_Instruction i)  ::   ( d2  ::  S )  ) ) (SE_Stack  ( d3  ::  S ) )
 | bs_drop : forall (d:data) (S:list data),
     BigStep i_Drop (SE_Stack  ( d  ::  S ) ) (SE_Stack S)
 | bs_dup : forall (d:data) (S:list data),
     BigStep i_Dup (SE_Stack  ( d  ::  S ) ) (SE_Stack  ( d  ::   ( d  ::  S )  ) )
 | bs_swap : forall (d1 d2:data) (S:list data),
     BigStep i_Swap (SE_Stack  ( d1  ::   ( d2  ::  S )  ) ) (SE_Stack  ( d2  ::   ( d1  ::  S )  ) )
 | bs_push : forall (ty:type) (d:data) (S:list data),
     BigStep (i_Push ty d) (SE_Stack S) (SE_Stack  ( d  ::  S ) )
 | bs_unit : forall (S:list data),
     BigStep i_Unit (SE_Stack S) (SE_Stack  ( d_Unit  ::  S ) )
 | bs_lambda : forall (ty ty':type) (i:instruction) (S:list data),
     BigStep (i_Lambda ty ty' i) (SE_Stack S) (SE_Stack  ( (d_Instruction i)  ::  S ) )
 | bs_eq_tt : forall (S:list data),
     BigStep i_Eq (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_eq_ff : forall (z:Z) (S:list data),
      lift_num2 (fun (A : Type) (d d' : A) =>
                            not (d = d'))  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Eq (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_neq_ff : forall (S:list data),
     BigStep i_Neq (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_neq_tt : forall (z:Z) (S:list data),
      lift_num2 (fun (A : Type) (d d' : A) =>
                            not (d = d'))  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Neq (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_lt_tt : forall (z:Z) (S:list data),
      lift_num lt Z.lt  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Lt (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_lt_ff : forall (z:Z) (S:list data),
      lift_num ge Z.ge  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Lt (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_gt_tt : forall (z:Z) (S:list data),
      lift_num gt Z.gt  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Gt (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_gt_ff : forall (z:Z) (S:list data),
      lift_num le Z.le  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Gt (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_le_tt : forall (z:Z) (S:list data),
      lift_num le Z.le  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Le (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_le_ff : forall (z:Z) (S:list data),
      lift_num gt Z.gt  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Le (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_ge : forall (z:Z) (S:list data),
      lift_num ge Z.ge  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Ge (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_lt : forall (z:Z) (S:list data),
      lift_num lt Z.lt  (N_IntConstant z)   (N_IntConstant  0 )  ->
     BigStep i_Ge (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_or : forall (b1:bool) (S:list data) (b2:bool),
     BigStep i_Or (SE_Stack  ( (d_BoolConstant b1)  ::   ( (d_BoolConstant b1)  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  (   orb    b1   b2  ) )  ::  S ) )
 | bs_and : forall (b1 b2:bool) (S:list data),
     BigStep i_And (SE_Stack  ( (d_BoolConstant b1)  ::   ( (d_BoolConstant b2)  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  (   andb    b1   b2  ) )  ::  S ) )
 | bs_xor : forall (b1 b2:bool) (S:list data),
     BigStep i_Xor (SE_Stack  ( (d_BoolConstant b1)  ::   ( (d_BoolConstant b2)  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  (   xorb    b1   b2  ) )  ::  S ) )
 | bs_not : forall (b:bool) (S:list data),
     BigStep i_Not (SE_Stack  ( (d_BoolConstant b)  ::  S ) ) (SE_Stack  ( (d_BoolConstant  ( negb  b  ) )  ::  S ) )
 | bs_neg : forall (N:num) (S:list data),
     BigStep i_Neg (SE_Stack  ( (d_Num N)  ::  S ) ) (SE_Stack  ( (d_Num  ( num_neg  N  ) )  ::  S ) )
 | bs_abs : forall (z:Z) (S:list data),
     BigStep i_Abs (SE_Stack  ( (d_Num (N_IntConstant z))  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant  (Z.abs_nat  z ) ))  ::  S ) )
 | bs_add : forall (N N':num) (S:list data),
     BigStep i_Add (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_aop  aop_Add   N   N'  ) )  )   ::  S ) )
 | bs_sub : forall (N N':num) (S:list data),
     BigStep i_Sub (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_aop  aop_Sub   N   N'  ) )  )   ::  S ) )
 | bs_mul : forall (N N':num) (S:list data),
     BigStep i_Mul (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_aop  aop_Mul   N   N'  ) )  )   ::  S ) )
 | bs_ediv_0 : forall (N N':num) (S:list data),
      num_neq_zero  N  ->
     BigStep i_EDiv (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  ( d_None  ::  S ) )
 | bs_ediv : forall (N N':num) (S:list data),
      num_neq_zero  N  ->
     BigStep i_EDiv (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  ( (d_Some  (  (d_Pair  (  (d_Num  ( num_apply_aop  aop_Div   N   N'  ) )  )   (  (d_Num  ( num_apply_aop  aop_Mod   N   N'  ) )  ) )  ) )  ::  S ) )
 | bs_bit_or : forall (n n':nat) (S:list data),
     BigStep i_Or (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_bitop  bitop_Or   (N_NatConstant n)   (N_NatConstant n')  ) )  )   ::  S ) )
 | bs_bit_and : forall (N N':num) (S:list data),
     BigStep i_And (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_bitop  bitop_And   N   N'  ) )  )   ::  S ) )
 | bs_bit_xor : forall (n n':nat) (S:list data),
     BigStep i_Xor (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_bitop  bitop_Xor   (N_NatConstant n)   (N_NatConstant n')  ) )  )   ::  S ) )
 | bs_bit_not : forall (N:num) (S:list data),
     BigStep i_Not (SE_Stack  ( (d_Num N)  ::  S ) ) (SE_Stack  ( (d_Num  ( num_bit_neg  N  ) )  ::  S ) )
 | bs_lsl : forall (n n':nat) (S:list data),
      lift_num le Z.le  (N_NatConstant n')   (N_NatConstant  256 )  ->
     BigStep i_Lsl (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_aop  aop_Lsl   (N_NatConstant n)   (N_NatConstant n')  ) )  )   ::  S ) )
 | bs_lsl_fail : forall (n n':nat) (S:list data),
      lift_num gt Z.gt  (N_NatConstant n')   (N_NatConstant  256 )  ->
     BigStep i_Lsl (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::  S )  ) ) SE_Failed
 | bs_lsr : forall (n n':nat) (S:list data),
     BigStep i_Lsr (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::  S )  ) ) (SE_Stack  (  (  (d_Num  ( num_apply_aop  aop_Lsr   (N_NatConstant n)   (N_NatConstant n')  ) )  )   ::  S ) )
 | bs_compare_num_lt : forall (N N':num) (S:list data),
      lift_num lt Z.lt  N   N'  ->
     BigStep i_Compare (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::  S ) )
 | bs_compare_num_eq : forall (N N':num) (S:list data),
      lift_num2 (@eq)  N   N'  ->
     BigStep i_Compare (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::  S ) )
 | bs_compare_num_gt : forall (N N':num) (S:list data),
      lift_num gt Z.gt  N   N'  ->
     BigStep i_Compare (SE_Stack  ( (d_Num N)  ::   ( (d_Num N')  ::  S )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::  S ) )
 | bs_concat_string : forall (s t:string) (S:list data),
     BigStep i_Concat (SE_Stack  ( (d_StringConstant s)  ::   ( (d_StringConstant t)  ::  S )  ) ) (SE_Stack  ( (d_StringConstant  (append  s   t ) )  ::  S ) )
 | bs_concat_list_nil : forall (S:list data),
     BigStep i_Concat (SE_Stack  ( (d_DataList  [] )  ::  S ) ) (SE_Stack  ( (d_StringConstant  ("") )  ::  S ) )
 | bs_concat_list_cons : forall (s:string) (l S:list data) (t:string),
     BigStep i_Concat (SE_Stack  ( (d_DataList  l )  ::  S ) ) (SE_Stack  ( (d_StringConstant t)  ::  S ) ) ->
     BigStep i_Concat (SE_Stack  ( (d_DataList  ( (d_StringConstant s)  ::   l  ) )  ::  S ) ) (SE_Stack  ( (d_StringConstant  (append  s   t ) )  ::  S ) )
 | bs_size_string : forall (s:string) (S:list data),
     BigStep i_Size (SE_Stack  ( (d_StringConstant s)  ::  S ) ) (SE_Stack  (  (  (d_Num (N_NatConstant  (String.length s) ))  )   ::  S ) )
 | bs_slice_some : forall (n n':nat) (s:string) (S:list data),
      lift_num lt Z.lt   ( num_apply_aop  aop_Add   (N_NatConstant n)   (N_NatConstant n')  )    (N_NatConstant  (String.length s) )  ->
     BigStep i_Slice (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::   ( (d_StringConstant s)  ::  S )  )  ) ) (SE_Stack  ( (d_Some  (  (d_StringConstant  (substring  n   n'   s ) )  ) )  ::  S ) )
 | bs_slice : forall (n n':nat) (s:string) (S:list data),
      lift_num ge Z.ge   ( num_apply_aop  aop_Add   (N_NatConstant n)   (N_NatConstant n')  )    (N_NatConstant  (String.length s) )  ->
     BigStep i_Slice (SE_Stack  ( (d_Num (N_NatConstant n))  ::   ( (d_Num (N_NatConstant n'))  ::   ( (d_StringConstant s)  ::  S )  )  ) ) (SE_Stack  ( d_None  ::  S ) )
 | bs_compare_string_lt : forall (s t:string) (S:list data),
      TODO  ->
     BigStep i_Compare (SE_Stack  ( (d_StringConstant s)  ::   ( (d_StringConstant t)  ::  S )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::  S ) )
 | bs_compare_string_eq : forall (s t:string) (S:list data),
      TODO  ->
     BigStep i_Compare (SE_Stack  ( (d_StringConstant s)  ::   ( (d_StringConstant t)  ::  S )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::  S ) )
 | bs_compare_string_gt : forall (s t:string) (S:list data),
      TODO  ->
     BigStep i_Compare (SE_Stack  ( (d_StringConstant s)  ::   ( (d_StringConstant t)  ::  S )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::  S ) )
 | bs_pair : forall (d d':data) (S:list data),
     BigStep i_Pair (SE_Stack  ( d  ::   ( d'  ::  S )  ) ) (SE_Stack  (  (  (d_Pair d d')  )   ::  S ) )
 | bs_car : forall (d d':data) (S:list data),
     BigStep i_Car (SE_Stack  (  (  (d_Pair d d')  )   ::  S ) ) (SE_Stack  ( d  ::  S ) )
 | bs_cdr : forall (d d':data) (S:list data),
     BigStep i_Cdr (SE_Stack  (  (  (d_Pair d d')  )   ::  S ) ) (SE_Stack  ( d'  ::  S ) )
 | bs_set_empty : forall (ty:type) (S:list data),
     BigStep (i_EmptySet ty) (SE_Stack S) (SE_Stack  ( (d_Set  [] )  ::  S ) )
 | bs_set_mem_empty : forall (x:data) (S:list data),
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Set  [] )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_set_mem_later : forall (x y:data) (set5 S:list data) (b:bool),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::   []  ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Set set5)  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant b)  ::  S ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant b)  ::  S ) )
 | bs_set_mem_found : forall (x y:data) (set5 S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_set_mem_nexists : forall (x y:data) (set5 S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_set_update_false : forall (x:data) (S:list data),
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant  false )  ::   ( (d_Set  [] )  ::  S )  )  ) ) (SE_Stack  ( (d_Set  [] )  ::  S ) )
 | bs_set_update_add_nexists : forall (x:data) (S:list data),
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant  true )  ::   ( (d_Set  [] )  ::  S )  )  ) ) (SE_Stack  ( (d_Set  [  x  ] )  ::  S ) )
 | bs_set_update_cont : forall (x:data) (b:bool) (y:data) (set5 S set':list data) (d:data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( d  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant b)  ::   ( (d_Set set5)  ::  S )  )  ) ) (SE_Stack  ( (d_Set set')  ::  S ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant b)  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Set  ( y  ::   set'  ) )  ::  S ) )
 | bs_set_update_remove : forall (x y:data) (set5 S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant  false )  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Set set5)  ::  S ) )
 | bs_set_update_exists : forall (x y:data) (set5 S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant  true )  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Set  ( y  ::   set5  ) )  ::  S ) )
 | bs_set_update_remove_nexists : forall (x y:data) (set5 S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant  false )  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Set  ( y  ::   set5  ) )  ::  S ) )
 | bs_set_update_add : forall (x y:data) (set5 S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( y  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_BoolConstant  true )  ::   ( (d_Set  ( y  ::   set5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Set  ( x  ::   ( y  ::   set5  )  ) )  ::  S ) )
 | bs_set_iter_nil : forall (body:instruction) (S:list data),
     BigStep (i_Iter body) (SE_Stack  ( (d_Set  [] )  ::  S ) ) (SE_Stack S)
 | bs_set_iter_cons : forall (body:instruction) (hd:data) (set5 S S':list data),
     BigStep (i_Seq body (i_Iter body)) (SE_Stack  ( hd  ::   ( (d_Set  set5 )  ::  S )  ) ) (SE_Stack S') ->
     BigStep (i_Iter body) (SE_Stack  ( (d_Set  ( hd  ::   set5  ) )  ::  S ) ) (SE_Stack S')
 | bs_set_size_nil : forall (S:list data),
     BigStep i_Size (SE_Stack  ( (d_Set  [] )  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant  0 ))  ::  S ) )
 | bs_set_size_cons : forall (d:data) (set5 S:list data) (n:nat),
     BigStep i_Size (SE_Stack  ( (d_Set  [  (d_Set  set5 )  ] )  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant n))  ::  S ) ) ->
     BigStep i_Size (SE_Stack  ( (d_Set  ( d  ::   set5  ) )  ::  S ) ) (SE_Stack  ( (d_Num  ( num_apply_aop  aop_Add   (N_NatConstant  1 )   (N_NatConstant n)  ) )  ::  S ) )
 | bs_map_empty : forall (ct:ctype) (ty:type) (S:list data),
     BigStep (i_EmptyMap ct ty) (SE_Stack S) (SE_Stack  ( (d_Map  [] )  ::  S ) )
 | bs_get_empty : forall (x:data) (S:list data),
     BigStep i_Get (SE_Stack  ( x  ::   ( (d_Map  [] )  ::  S )  ) ) (SE_Stack  ( d_None  ::  S ) )
 | bs_get_later : forall (x k v:data) (map5:list (data * data)) (S:list data) (opt_y:data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::   []  ) ) ->
     BigStep i_Get (SE_Stack  ( x  ::   ( (d_Map  map5 )  ::  S )  ) ) (SE_Stack  ( opt_y  ::  S ) ) ->
     BigStep i_Get (SE_Stack  ( x  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  ) ) (SE_Stack  ( opt_y  ::  S ) )
 | bs_get_now : forall (x k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Get (SE_Stack  ( x  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  ) ) (SE_Stack  ( (d_Some v)  ::  S ) )
 | bs_get_nexists : forall (x k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Get (SE_Stack  ( x  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  ) ) (SE_Stack  ( d_None  ::  S ) )
 | bs_map_mem_empty : forall (x:data) (S:list data),
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Map  [] )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_map_mem_later : forall (x k v:data) (map5:list (data * data)) (S:list data) (r:bool),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::   []  ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Map  map5 )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant r)  ::  S ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant r)  ::  S ) )
 | bs_map_mem_now : forall (x k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  true )  ::  S ) )
 | bs_map_mem_nexists : forall (x k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Mem (SE_Stack  ( x  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  ) ) (SE_Stack  ( (d_BoolConstant  false )  ::  S ) )
 | bs_map_update_false : forall (x:data) (S:list data),
     BigStep i_Update (SE_Stack  ( x  ::   ( d_None  ::   ( (d_Map  [] )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  [] )  ::  S ) )
 | bs_map_update_add_nexists : forall (x y:data) (S:list data),
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_Some y)  ::   ( (d_Map  [] )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  [ ( x ,  y ) ] )  ::  S ) )
 | bs_map_update_cont : forall (x opt_y k v:data) (map5:list (data * data)) (S:list data) (map':list (data * data)),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  1 ))  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( opt_y  ::   ( (d_Map  map5 )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  map' )  ::  S ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( opt_y  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  (( k ,  v )::  map'  ) )  ::  S ) )
 | bs_map_update_remove : forall (x k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( d_None  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  map5 )  ::  S ) )
 | bs_map_update_exists : forall (x y k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num (N_IntConstant  0 ))  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_Some y)  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  (( k ,  y )::  map5  ) )  ::  S ) )
 | bs_map_update_remove_nexists : forall (x k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( d_None  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  (( k ,  v )::  map5  ) )  ::  S ) )
 | bs_map_update_add : forall (x y k v:data) (map5:list (data * data)) (S:list data),
     BigStep i_Compare (SE_Stack  ( x  ::   ( k  ::   []  )  ) ) (SE_Stack  ( (d_Num  ( num_neg  (N_IntConstant  1 )  ) )  ::   []  ) ) ->
     BigStep i_Update (SE_Stack  ( x  ::   ( (d_Some y)  ::   ( (d_Map  (( k ,  v )::  map5  ) )  ::  S )  )  ) ) (SE_Stack  ( (d_Map  (( x ,  y )::  (( k ,  v )::  map5  )  ) )  ::  S ) )
 | bs_map_map_nil : forall (body:instruction) (S:list data),
     BigStep (i_Map body) (SE_Stack  ( (d_Map  [] )  ::  S ) ) (SE_Stack  ( (d_Map  [] )  ::  S ) )
 | bs_map_map_cons : forall (body:instruction) (k v:data) (map5:list (data * data)) (S:list data) (v':data) (map':list (data * data)),
     BigStep body (SE_Stack  ( k  ::   ( v  ::  S )  ) ) (SE_Stack  ( v'  ::  S ) ) ->
     BigStep (i_Map body) (SE_Stack  ( (d_Map  map5 )  ::  S ) ) (SE_Stack  ( (d_Map  map' )  ::  S ) ) ->
     BigStep (i_Map body) (SE_Stack  ( (d_Map  (( k ,  v )::  map5  ) )  ::  S ) ) (SE_Stack  ( (d_Map  (( k ,  v' )::  map'  ) )  ::  S ) )
 | bs_map_iter_nil : forall (body:instruction) (S:list data),
     BigStep (i_Iter body) (SE_Stack  ( (d_Map  [] )  ::  S ) ) (SE_Stack S)
 | bs_map_iter_cons : forall (body:instruction) (k v:data) (map5:list (data * data)) (S S':list data),
     BigStep (i_Seq body (i_Iter body)) (SE_Stack  (  (  (d_Pair k v)  )   ::   ( (d_Map  map5 )  ::  S )  ) ) (SE_Stack S') ->
     BigStep (i_Iter body) (SE_Stack  ( (d_Map  (( k ,  v )::  map5  ) )  ::  S ) ) (SE_Stack S')
 | bs_map_size_nil : forall (S:list data),
     BigStep i_Size (SE_Stack  ( (d_Map  [] )  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant  0 ))  ::  S ) )
 | bs_map_size_cons : forall (d d':data) (map5:list (data * data)) (S:list data) (n:nat),
     BigStep i_Size (SE_Stack  ( (d_Map  map5 )  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant n))  ::  S ) ) ->
     BigStep i_Size (SE_Stack  ( (d_Map  (( d ,  d' )::  map5  ) )  ::  S ) ) (SE_Stack  ( (d_Num  ( num_apply_aop  aop_Add   (N_NatConstant  1 )   (N_NatConstant n)  ) )  ::  S ) )
 | bs_some : forall (v:data) (S:list data),
     BigStep i_Some (SE_Stack  ( v  ::  S ) ) (SE_Stack  (  (  (d_Some v)  )   ::  S ) )
 | bs_none : forall (ty:type) (v:data) (S:list data),
     BigStep (i_None ty) (SE_Stack  ( v  ::  S ) ) (SE_Stack  ( d_None  ::  S ) )
 | bs_if_none : forall (bt bf:instruction) (S S':list data),
     BigStep bt (SE_Stack S) (SE_Stack S') ->
     BigStep (i_IfNone bt bf) (SE_Stack  ( d_None  ::  S ) ) (SE_Stack S')
 | bs_if_some : forall (bt bf:instruction) (d:data) (S S':list data),
     BigStep bf (SE_Stack  ( d  ::  S ) ) (SE_Stack S') ->
     BigStep (i_IfNone bt bf) (SE_Stack  (  (  (d_Some d)  )   ::  S ) ) (SE_Stack S')
 | bs_pack_left : forall (ty:type) (v:data) (S:list data),
     BigStep (i_Left ty) (SE_Stack  ( v  ::  S ) ) (SE_Stack  (  (  (d_Left v)  )   ::  S ) )
 | bs_pack_right : forall (ty:type) (v:data) (S:list data),
     BigStep (i_Right ty) (SE_Stack  ( v  ::  S ) ) (SE_Stack  (  (  (d_Right v)  )   ::  S ) )
 | bs_if_left_left : forall (bt bf:instruction) (d:data) (S S':list data),
     BigStep bt (SE_Stack  ( d  ::  S ) ) (SE_Stack S') ->
     BigStep (i_IfLeft bt bf) (SE_Stack  (  (  (d_Left d)  )   ::  S ) ) (SE_Stack S')
 | bs_if_left_right : forall (bt bf:instruction) (d:data) (S S':list data),
     BigStep bf (SE_Stack  ( d  ::  S ) ) (SE_Stack S') ->
     BigStep (i_IfLeft bt bf) (SE_Stack  (  (  (d_Right d)  )   ::  S ) ) (SE_Stack S')
 | bs_if_right_right : forall (bt bf:instruction) (d:data) (S S':list data),
     BigStep bt (SE_Stack  ( d  ::  S ) ) (SE_Stack S') ->
     BigStep (i_IfRight bt bf) (SE_Stack  (  (  (d_Right d)  )   ::  S ) ) (SE_Stack S')
 | bs_if_right_left : forall (bt bf:instruction) (d:data) (S S':list data),
     BigStep bf (SE_Stack  ( d  ::  S ) ) (SE_Stack S') ->
     BigStep (i_IfRight bt bf) (SE_Stack  (  (  (d_Left d)  )   ::  S ) ) (SE_Stack S')
 | bs_cons : forall (d:data) (l S:list data),
     BigStep i_Cons (SE_Stack  ( d  ::   ( (d_DataList  l )  ::  S )  ) ) (SE_Stack  ( (d_DataList  ( d  ::   l  ) )  ::  S ) )
 | bs_nil : forall (ty:type) (S:list data),
     BigStep (i_Nil ty) (SE_Stack S) (SE_Stack  ( (d_DataList  [] )  ::  S ) )
 | bs_if_cons_cons : forall (bt bf:instruction) (d:data) (l S S':list data),
     BigStep bt (SE_Stack  ( d  ::   ( (d_DataList  l )  ::  S )  ) ) (SE_Stack S') ->
     BigStep (i_IfCons bt bf) (SE_Stack  ( (d_DataList  ( d  ::   l  ) )  ::  S ) ) (SE_Stack S')
 | bs_if_cons_nil : forall (bt bf:instruction) (S S':list data),
     BigStep bf (SE_Stack S) (SE_Stack S') ->
     BigStep (i_IfCons bt bf) (SE_Stack  ( (d_DataList  [] )  ::  S ) ) (SE_Stack S')
 | bs_list_map_cons : forall (body:instruction) (d:data) (l S:list data) (d':data) (l':list data),
     BigStep body (SE_Stack  ( d  ::  S ) ) (SE_Stack  ( d'  ::  S ) ) ->
     BigStep (i_Map body) (SE_Stack  ( (d_DataList  l )  ::  S ) ) (SE_Stack  ( (d_DataList  l' )  ::  S ) ) ->
     BigStep (i_Map body) (SE_Stack  ( (d_DataList  ( d  ::   l  ) )  ::  S ) ) (SE_Stack  ( (d_DataList  ( d'  ::   l'  ) )  ::  S ) )
 | bs_list_map_nil : forall (body:instruction) (S:list data),
     BigStep (i_Map body) (SE_Stack  ( (d_Set  [] )  ::  S ) ) (SE_Stack  ( (d_Set  [] )  ::  S ) )
 | bs_list_size_cons : forall (d:data) (l S:list data) (n:nat),
     BigStep i_Size (SE_Stack  ( (d_DataList  l )  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant n))  ::  S ) ) ->
     BigStep i_Size (SE_Stack  ( (d_DataList  ( d  ::   l  ) )  ::  S ) ) (SE_Stack  ( (d_Num  ( num_apply_aop  aop_Add   (N_NatConstant  1 )   (N_NatConstant n)  ) )  ::  S ) )
 | bs_list_size_nil : forall (S:list data),
     BigStep i_Size (SE_Stack  ( (d_Set  [] )  ::  S ) ) (SE_Stack  ( (d_Num (N_NatConstant  0 ))  ::  S ) )
 | bs_list_iter_cons : forall (body:instruction) (d:data) (l S S':list data),
     BigStep (i_Seq body (i_Iter body)) (SE_Stack  ( d  ::   ( (d_DataList  l )  ::  S )  ) ) (SE_Stack S') ->
     BigStep (i_Iter body) (SE_Stack  ( (d_DataList  ( d  ::   l  ) )  ::  S ) ) (SE_Stack S')
 | bs_list_iter_nil : forall (body:instruction) (S:list data),
     BigStep (i_Iter body) (SE_Stack  ( (d_Set  [] )  ::  S ) ) (SE_Stack S).


