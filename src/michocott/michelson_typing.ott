embed {{ coq
Require String.
Require Import ZArith.

Module Mutez.
  Inductive mutez :=.
End Mutez.
}}

metavar nat_litteral ::= {{ coq N }}
metavar int_litteral ::= {{ coq Z }}
metavar string_litteral ::= {{ coq String.string }}
metavar timestamp_litteral ::= {{ coq Z }}
metavar signature_litteral ::= {{ coq String.string }}
metavar key_litteral ::= {{ coq String.string }}
metavar key_hash_litteral ::= {{ coq String.string }}
metavar mutez_litteral ::= {{ coq Mutez.mutez }}
metavar contract_litteral ::= {{ coq String.string }}

indexvar n ::= {{ coq nat }}

grammar




comparable_type, c, kty :: cty_ ::=
  | string    :: :: string
  | nat       :: :: nat
  | int       :: :: int
  | bytes     :: :: bytes
  | bool      :: :: bool
  | mutez     :: :: mutez
  | key_hash  :: :: key_hash
  | timestamp :: :: timestamp

type, a, b, ty, vty :: ty_ ::=
  | c               :: :: Comparable_type
  | key             :: :: key
  | unit            :: :: unit
  | signature       :: :: signature
  | option type     :: :: option
  | list type       :: :: list
  | set c           :: :: set
  | contract type   :: :: contract
  | address         :: :: address
  | operation       :: :: operation
  | pair a b        :: :: pair
  | or a b          :: :: or
  | lambda a b      :: :: lambda
  | map kty vty     :: :: map
  | big_map kty vty :: :: big_map
  | self_ty         :: M :: self_ty {{coq self_ty}}
  | ( a )           :: M :: parens {{coq ([[a]])}}


data, x, y, z, k, v, d :: data_ ::=
  | int_litteral :: :: int
  | nat_litteral :: :: nat
  | string_litteral :: :: string
  | timestamp_litteral :: :: timestamp
  | signature_litteral :: :: signature
  | key_litteral :: :: key
  | key_hash_litteral :: :: key_hash
  | mutez_litteral :: :: mutez
  | contract_litteral :: :: contract
  | Unit :: :: Unit
  | True :: :: True
  | False :: :: False
  | Pair x y :: :: Pair
  | Left x :: :: Left
  | Right y :: :: Right
  | Some x :: :: Some
  | None :: :: None
  | { x1 ; .. ; xn } :: :: list_or_set
  | { map_elt1 ; .. ; map_eltn } :: :: map
  | code :: :: instruction
  | 0 :: M :: zero {{ coq data_int 0%Z}}

map_elt :: '' ::=
  | Elt k v :: :: Elt

comparison :: '' ::=
  | EQ :: :: EQ
  | NEQ :: :: NEQ
  | LT :: :: LT
  | GT :: :: GT
  | LE :: :: LE
  | GE :: :: GE

binary_bitwise :: '' ::=
  | OR :: :: OR
  | AND :: :: AND
  | XOR :: :: XOR

hash_function :: '' ::=
  | HASH_KEY :: :: HASH_KEY
  | BLAKE2B :: :: BLAKE2B
  | SHA256 :: :: SHA256
  | SHA512 :: :: SHA512

nullary :: '' ::=
  | PUSH a x :: :: PUSH
  | UNIT :: :: UNIT
  | LAMBDA a b code :: :: LAMBDA
  | EMPTY_SET c :: :: EMPTY_SET
  | EMPTY_MAP kty vty :: :: EMPTY_MAP
  | NONE a :: :: NONE
  | NIL a :: :: NIL
  | BALANCE :: :: BALANCE
  | SOURCE :: :: SOURCE
  | SENDER :: :: SENDER
  | SELF :: :: SELF
  | AMOUNT :: :: AMOUNT
  | STEPS_TO_QUOTA :: :: STEPS_TO_QUOTA
  | NOW :: :: NOW

unary :: '' ::=
  | comparison :: :: unary_comparison
  | hash_function :: :: unary_hash
  | NOT :: :: NOT
  | NEG :: :: NEG
  | ABS :: :: ABS
  | SIZE :: :: SIZE
  | CAR :: :: CAR
  | CDR :: :: CDR
  | SOME :: :: SOME
  | LEFT b :: :: LEFT
  | RIGHT a :: :: RIGHT
  | ADDRESS :: :: ADDRESS
  | CONTRACT a :: :: CONTRACT
  | SET_DELEGATE :: :: SET_DELEGATE
  | IMPLICIT_ACCOUNT :: :: IMPLICIT_ACCOUNT
  | PACK :: :: PACK
  | UNPACK a :: :: UNPACK

binary :: '' ::=
  | binary_bitwise :: :: b_bitwise
  | EXEC :: :: EXEC
  | LSL :: :: LSL
  | LSR :: :: LSR
  | COMPARE :: :: COMPARE
  | CONCAT :: :: CONCAT
  | PAIR :: :: PAIR
  | MEM :: :: MEM
  | GET :: :: GET
  | CONS :: :: CONS

non_failing_function :: '' ::=
  | nullary :: :: nff_nullary
  | unary :: :: nff_unary
  | binary :: :: nff_binary

  | DROP :: :: DROP
  | DUP :: :: DUP
  | SWAP :: :: SWAP

  | SLICE :: :: SLICE
  | UPDATE :: :: UPDATE
  | CREATE_CONTRACT :: :: CREATE_CONTRACT
  | CREATE_CONTRACT code :: :: CREATE_CONSTRACT_litteral
  | CREATE_ACCOUNT :: :: CREATE_ACCOUNT
  | TRANSFER_TOKENS :: :: TRANSFER_TOKENS
  | CHECK_SIGNATURE :: :: CHECK_SIGNATURE

function :: '' ::=
  | non_failing_function :: :: Non_failing
  | ADD :: :: ADD
  | SUB :: :: SUB
  | MUL :: :: MUL
  | EDIV :: :: EDIV

code, i :: '' ::=
  | function :: :: Fun
  | FAILWITH :: :: FAILWITH
  | {} :: :: NOOP
  | { code1 ; code2 } :: :: SEQ
  | IF code1 code2 :: :: IF_
  | LOOP code :: :: LOOP
  | LOOP_LEFT code :: :: LOOP_LEFT
  | DIP code :: :: DIP
  | ITER code :: :: ITER
  | MAP code :: :: MAP
  | IF_NONE code1 code2 :: :: IF_NONE
  | IF_LEFT code1 code2 :: :: IF_LEFT
  | IF_RIGHT code1 code2 :: :: IF_RIGHT
  | IF_CONS code1 code2 :: :: IF_CONS

stack_type, A, B, C :: Stack_type_ ::= {{ coq Datatypes.list type }} {{ phantom }}
  | [] :: :: empty {{ coq nil}}
  | a ':' A :: :: cons {{ coq (cons[[a]][[A]])}}
  | A @ B :: M :: append {{ coq (List.app[[A]][[B]])}}

stack, st, S :: Stack_ ::=
  | [] :: :: empty
  | data : stack :: :: cons

% A stackerr is either failed or a stack, which is a list of data.
stackerr, SE :: 'SE_' ::=
       | [FAILED] :: :: Failed
       | stack :: :: Stack

% embed {{coq
% Definition compare x comp y :=
%     match x, y with
%     | data_int x, data_int y =>
%          match comp with
%          | EQ => x = y
%          | NEQ => x <> y
%          | LT => x < y
%          | GT => x > y
%          | LE => x <= y
%          | GE => x >= y
%          end
%     | _ => False
%     end.}}

formula :: formula_ ::=
  | judgement :: :: judgement
  | formula1 .. formulan :: :: dots
  | get_contract_type contract_litteral a :: M :: get_contract_rel
    {{ coq get_contract_rel [[contract_litteral]] [[a]] }}
  | x = y :: M :: eq {{coq (compare [[x]] EQ [[y]])}}
  | x <> y :: M :: neq {{coq (compare [[x]] NEQ [[y]])}}
  | x < y :: M :: lt {{coq (compare [[x]] LT [[y]])}}
  | x > y :: M :: gt {{coq (compare [[x]] GT [[y]])}}
  | x <= y :: M :: le {{coq (compare [[x]] LE [[y]])}}
  | x >= y :: M :: ge {{coq (compare [[x]] GE [[y]])}}

embed {{coq
Section syntax.
  Variable self_ty : type.
  Variable get_contract_rel : String.string -> type -> Prop.
}}


defns
Typing :: 't_' ::=

  defn
  x '::' a :: :: data_has_type :: 'data_' by

       ------------------ :: int
       int_litteral :: int

       ------------------ :: nat
       nat_litteral :: nat

       ------------------------ :: string
       string_litteral :: string

       ------------------------------ :: timestamp
       timestamp_litteral :: timestamp

       ------------------------------ :: signature
       signature_litteral :: signature

       ------------------ :: key
       key_litteral :: key

       ---------------------------- :: key_hash
       key_hash_litteral :: key_hash

       ---------------------- :: mutez
       mutez_litteral :: mutez

       get_contract_type contract_litteral a
       ------------------------------------- :: contract
       contract_litteral :: contract a

       ----------- :: Unit
       Unit :: unit

       ----------- :: True
       True :: bool

       ------------ :: False
       False :: bool

       x :: a
       y :: b
       ------------------- :: Pair
       Pair x y :: pair a b

       x :: a
       --------------- :: Left
       Left x :: or a b

       y :: b
       ---------------- :: Right
       Right y :: or a b

       x :: a
       ----------------- :: Some
       Some x :: option a

       --------------- :: None
       None :: option a

       x1 :: c .. xn :: c
       ------------------------ :: set
       { x1 ; .. ; xn } :: set c

       x1 :: a .. xn :: a
       ------------------------- :: list
       { x1 ; .. ; xn } :: list a

       map_elt1 :: kty, vty .. map_eltn :: kty, vty
       --------------------------------------------- :: map
       { map_elt1 ; .. ; map_eltn } :: map kty vty

       code :: a : [] => b : []
       ------------------------- :: instruction
       code :: lambda a b

  defn
  map_elt '::' kty, vty :: :: map_elt_has_type :: 'map_elt_' by

       k :: kty
       v :: vty
       ------------------ :: map_elt
       Elt k v :: kty, vty

  defn
  nullary '::' -> a :: :: null_has_type :: 'fun0_' by

       x :: a
       --------------- :: PUSH
       PUSH a x :: -> a

       -------------- :: UNIT
       UNIT :: -> unit

       code :: a : [] => b : []
       ------------------------------- :: LAMBDA
       LAMBDA a b code :: -> lambda a b

       ---------------------- :: EMPTY_SET
       EMPTY_SET c :: -> set c

       ---------------------------------- :: EMPTY_MAP
       EMPTY_MAP kty vty :: -> map kty vty

       -------------------- :: NONE
       NONE a :: -> option a

       ----------------- :: NIL
       NIL a :: -> list a

       ------------------ :: BALANCE
       BALANCE :: -> mutez

       ------------------- :: SOURCE
       SOURCE :: -> address

       ------------------- :: SENDER
       SENDER :: -> address

       ----------------- :: SELF
       SELF :: -> self_ty

       ----------------- :: AMOUNT
       AMOUNT :: -> mutez

       ----------------------- :: STEPS_TO_QUOTA
       STEPS_TO_QUOTA :: -> nat

       ------------------ :: NOW
       NOW :: -> timestamp

  defn
  unary '::' a -> b :: :: unary_has_type :: 'fun1_' by

       ------------------------ :: comparison
       comparison :: int -> bool

       ------------------ :: NOT_bool
       NOT :: bool -> bool

       ---------------- :: NOT_nat
       NOT :: nat -> int

       ---------------- :: NOT_int
       NOT :: int -> int

       ---------------- :: NEG_nat
       NEG :: nat -> int

       ---------------- :: NEG_int
       NEG :: int -> int

       ---------------- :: ABS
       ABS :: int -> nat

       ------------------- :: SIZE_set
       SIZE :: set c -> nat

       ------------------------- :: SIZE_map
       SIZE :: map kty vty -> nat

       -------------------- :: SIZE_list
       SIZE :: list a -> nat

       -------------------- :: SIZE_string
       SIZE :: string -> nat

       ------------------- :: SIZE_bytes
       SIZE :: bytes -> nat

       ------------------- :: CAR
       CAR :: pair a b -> a

       ------------------- :: CDR
       CDR :: pair a b -> b

       -------------------- :: SOME
       SOME :: a -> option a

       -------------------- :: LEFT
       LEFT b :: a -> or a b

       --------------------- :: RIGHT
       RIGHT a :: b -> or a b

       ------------------------------- :: ADDRESS
       ADDRESS :: contract a -> address

       ---------------------------------- :: CONTRACT
       CONTRACT a :: address -> contract a

       ------------------------------------------- :: SET_DELEGATE
       SET_DELEGATE :: option key_hash -> operation

       -------------------------------------------- :: IMPLICIT_ACCOUNT
       IMPLICIT_ACCOUNT :: key_hash -> contract unit

       ----------------- :: PACK
       PACK :: a -> bytes

       --------------------- :: UNPACK
       UNPACK a :: bytes -> a

       -------------------------- :: HASH_KEY
       HASH_KEY :: key -> key_hash

       ------------------------------ :: HASH
       hash_function :: bytes -> bytes

  defn
  binary '::' a1 -> a2 -> b :: :: bin_has_type :: 'fun2_' by

       ------------------------------------- :: bitwise_bool
       binary_bitwise :: bool -> bool -> bool

       ---------------------------------- :: bitwise_nat
       binary_bitwise :: nat -> nat -> nat

       --------------------------- :: EXEC
       EXEC :: a -> lambda a b -> b

       ----------------------- :: LSL
       LSL :: nat -> nat -> nat

       ----------------------- :: LSR
       LSR :: nat -> nat -> nat

       ----------------------- :: COMPARE
       COMPARE :: c -> c -> int

       ----------------------------------- :: CONCAT_string
       CONCAT :: string -> string -> string

       -------------------------------- :: CONCAT_bytes
       CONCAT :: bytes -> bytes -> bytes

       ------------------------- :: PAIR
       PAIR :: a -> b -> pair a b

       ------------------------ :: MEM_set
       MEM :: c -> set c -> bool

       -------------------------------- :: MEM_map
       MEM :: kty -> map kty vty -> bool

       ------------------------------------ :: MEM_big_map
       MEM :: kty -> big_map kty vty -> bool

       -------------------------------------- :: GET_map
       GET :: kty -> map kty vty -> option vty

       ------------------------------------------ :: GET_big_map
       GET :: kty -> big_map kty vty -> option vty

       ---------------------------- :: CONS
       CONS :: a -> list a -> list a

  defn
  function '::' A -> B :: :: fun_has_type :: 'fun_' by

       nullary :: a
       ----------------------- :: nullary
       nullary :: [] -> a : []

       unary :: a -> b
       -------------------------- :: unary
       unary :: a : [] -> b : []

       binary :: a1 -> a2 -> b
       ---------------------------------- :: binary
       binary :: a1 : a2 : [] -> b : []

       -------------------- :: DROP
       DROP :: a : [] -> []

       ----------------------------- :: DUP
       DUP :: a : [] -> a : a : []

       ----------------------------------- :: SWAP
       SWAP :: a : b : [] -> b : a : []

       --------------------------------------------------------- :: SLICE_string
       SLICE :: nat : nat : string : [] -> option string : []

       ------------------------------------------------------- :: SLICE_bytes
       SLICE :: nat : nat : bytes : [] -> option bytes : []

       ------------------------------------------------ :: UPDATE_set
       UPDATE :: c : bool : set c : [] -> set c : []

       ------------------------------------------------------------- :: UPDATE_map
       UPDATE :: kty : vty : map kty vty : [] -> map kty vty : []

       --------------------------------------------------------------------- :: UPDATE_big_map
       UPDATE :: kty : vty : big_map kty vty : [] -> big_map kty vty : []


       -------------------------------------------------------------------------------------------------------------------------------------------------------------- :: CREATE_CONTRACT
       CREATE_CONTRACT :: key_hash : option key_hash : bool : bool : mutez : lambda (pair a b) (pair (list operation) b) : b : [] -> operation : address : []

       code :: pair a b : [] => pair (list operation) b : []
       -------------------------------------------------------------------------------------------------------------------- :: CREATE_CONTRACT_l
       CREATE_CONTRACT code :: key_hash : option key_hash : bool : bool : mutez : b : [] -> operation : address : []


       ------------------------------------------------------------------------------------------------------- :: CREATE_ACCOUNT
       CREATE_ACCOUNT :: key_hash : option key_hash : bool : mutez : [] -> operation : contract unit : []


       ------------------------------------------------------------------- :: TRANSFER_TOKENS
       TRANSFER_TOKENS :: a : mutez : contract a : [] -> operation : []


       --------------------------------------------------------------- :: CHECK_SIGNATURE
       CHECK_SIGNATURE :: key : signature : bytes : [] -> bool : []


       ----------------------------------- :: ADD_nat_nat
       ADD :: nat : nat : [] -> nat : []

       ----------------------------------- :: ADD_nat_int
       ADD :: nat : int : [] -> int : []

       ----------------------------------- :: ADD_int_nat
       ADD :: int : nat : [] -> int : []

       ----------------------------------- :: ADD_int_int
       ADD :: int : int : [] -> int : []

       ----------------------------------------------- :: ADD_timestamp_int
       ADD :: timestamp : int : [] -> timestamp : []

       ----------------------------------------------- :: ADD_int_timestamp
       ADD :: int : timestamp : [] -> timestamp : []

       ----------------------------------------- :: ADD_mutez_mutez_mutez
       ADD :: mutez : mutez : [] -> mutez : []

       ----------------------------------- :: SUB_nat_nat
       SUB :: nat : nat : [] -> int : []

       ----------------------------------- :: SUB_nat_int
       SUB :: nat : int : [] -> int : []

       ----------------------------------- :: SUB_int_nat
       SUB :: int : nat : [] -> int : []

       ----------------------------------- :: SUB_int_int
       SUB :: int : int : [] -> int : []

       ----------------------------------------------- :: SUB_timestamp_int
       SUB :: timestamp : int : [] -> timestamp : []

       ----------------------------------------------- :: SUB_timestamp_timestamp
       SUB :: timestamp : timestamp : [] -> int : []

       ----------------------------------------- :: SUB_mutez_mutez
       SUB :: mutez : mutez : [] -> mutez : []

       ----------------------------------- :: MUL_nat_nat
       MUL :: nat : nat : [] -> nat : []

       ----------------------------------- :: MUL_nat_int
       MUL :: nat : int : [] -> int : []

       ----------------------------------- :: MUL_int_nat
       MUL :: int : nat : [] -> int : []

       ----------------------------------- :: MUL_int_int
       MUL :: int : int : [] -> int : []

       --------------------------------------- :: MUL_mutez_nat
       MUL :: mutez : nat : [] -> mutez : []

       --------------------------------------- :: MUL_nat_mutez
       MUL :: nat : mutez : [] -> mutez : []

       ------------------------------------------- :: EDIV_nat_nat
       EDIV :: nat : nat : [] -> nat : nat : []

       ------------------------------------------- :: EDIV_nat_int
       EDIV :: nat : int : [] -> int : nat : []

       ------------------------------------------- :: EDIV_int_nat
       EDIV :: int : nat : [] -> int : nat : []

       ------------------------------------------- :: EDIV_int_int
       EDIV :: int : int : [] -> int : nat : []

       ------------------------------------------------- :: EDIV_mutez_nat
       EDIV :: mutez : nat : [] -> mutez : mutez : []

       ------------------------------------------------- :: EDIV_mutez_mutez
       EDIV :: mutez : mutez : [] -> nat : mutez : []

  defn
  code '::' A => B :: :: code_has_type :: 'code_' by

       function :: A -> B
       ------------------------- :: function
       function :: A @ C => B @ C

       ---------------------- :: FAILWITH
       FAILWITH :: a : A => B

       ------------- :: NOOP
       {} :: A => A

       code1 :: A => B
       code2 :: B => C
       ------------------------ :: SEQ
       {code1; code2} :: A => C

       code1 :: A => B
       code2 :: A => B
       ------------------------------- :: IF
       IF code1 code2 :: bool : A => B

       code :: A => bool : A
       -------------------------- :: LOOP
       LOOP code :: bool : A => A

       code :: a : A => or a b : A
       --------------------------------- :: LOOP_LEFT
       LOOP_LEFT code :: or a b : A => A

       code :: A => B
       --------------------------- :: DIP
       DIP code :: a : A => a : B

       code :: a : A => A
       ---------------------------- :: ITER_list
       ITER code :: list a : A => A

       code :: c : A => A
       ---------------------------- :: ITER_set
       ITER code :: set c : A => A

       code :: (pair kty vty) : A => A
       --------------------------------- :: ITER_map
       ITER code :: map kty vty : A => A

       code :: a : A => b : A
       ------------------------------------- :: MAP_list
       MAP code :: list a : A => list b : A

       code :: (pair kty a) : A => b : A
       ------------------------------------------- :: MAP_map
       MAP code :: map kty a : A => map kty b : A

       code1 :: A => B
       code2 :: a : A => B
       ---------------------------------------- :: IF_NONE
       IF_NONE code1 code2 :: option a : A => B

       code1 :: a : A => B
       code2 :: b : A => B
       -------------------------------------- :: IF_LEFT
       IF_LEFT code1 code2 :: or a b : A => B

       code1 :: b : A => B
       code2 :: a : A => B
       -------------------------------------- :: IF_RIGHT
       IF_RIGHT code1 code2 :: or a b : A => B

       code1 :: a : list a : A => B
       code2 :: A => B
       -------------------------------------- :: IF_CONS
       IF_CONS code1 code2 :: list a : A => B

defns
BigStep :: '' ::=


%% A big-step goes from an instruction (which is possible a sequence
%% of instructions), an initial stack to a final stack.

% Local big-step rules
defn
i / stackerr => stackerr'  :: :: BigStep :: 'bs_'
{{ tex [[i]] / [[stackerr]] \Rightarrow [[stackerr']] }}
by


%%
%% Now follows the rules. As far as possible, I follow the look of the
%% rules in the Michelson documentation. However, premises are here placed
%% above the line "------- :: [rule_name]" and the sugar
%%
%%   i / S => i' / S'
%%
%%  is desugered to
%%
%% i' / S => S'
%% -------- ::
%% i / S => S'
%%
%% I've left the typing rules, not implemented, in comment, and some bits of the original documentation.
%% My comments are prefixed AJ:.
%%

------ :: failwith
FAILWITH / d : stack => [FAILED]

------ :: failed
i / [FAILED] => [FAILED]

i1 / S => SE''
i2 / SE'' => SE'
------ :: sequence
{i1; i2} / S => SE'

------ :: NOOP
{} / S => S

i1 / S => S'
------ :: if_tt
IF i1 i2 / True : S => S'

i2 / S => S'
------ :: if_ff
IF i1 i2 / False : S => S'

{i1; LOOP i1} / S => S'
------ :: loop_tt
LOOP i1 / True : S => S'

------ :: loop_ff
LOOP i1 / False : S => S

{i1 ; LOOP_LEFT i1} / d : S => S'
------ :: loop_left_tt
LOOP_LEFT i1 / Left d : S => S'

i1 / S => S'
------ :: dip
DIP i1 / d : S => d : S'

i / d2 : []  =>  d3 : []
------ :: exec
EXEC / i : d2 : S  =>  d3 : S


%%
%% Stack operations
%%
%     DROP: Drop the top element of the stack.

% :: _ : 'A   ->   'A

----- :: drop
DROP / d : S  =>  S

%     DUP: Duplicate the top of the stack.

% :: 'a : 'A   ->   'a : 'a : 'A

----- :: dup
DUP / d : S  =>  d : d : S

%     SWAP: Exchange the top two elements of the stack.

% :: 'a : 'b : 'A   ->   'b : 'a : 'A

----- :: swap
SWAP / d1 : d2 : S  =>  d2 : d1 : S

%     PUSH 'a x: Push a constant value of a given type onto the stack.

% :: 'A   ->   'a : 'A
%    iff   x :: 'a

----- :: push
PUSH ty d / S  =>  d : S

%     UNIT: Push a unit value onto the stack.

% :: 'A   ->   unit : 'A

----- :: unit
UNIT / S  =>  Unit : S

%     LAMBDA 'a 'b code: Push a lambda with given parameter and return types onto the stack.

% :: 'A ->  (lambda 'a 'b) : 'A

----- :: lambda
LAMBDA ty ty' i / S  =>  i : S


%%
%% Generic comparison
%%

%     EQ: Checks that the top of the stack EQuals zero.

% :: int : 'S   ->   bool : 'S

----- :: eq_tt
EQ / 0 : S  =>  True : S

z <> 0
----- :: eq_ff
EQ / z : S  =>  False : S

%     NEQ: Checks that the top of the stack does Not EQual zero.

% :: int : 'S   ->   bool : 'S

----- :: neq_ff
NEQ / 0 : S  =>  False : S

z <> 0
----- :: neq_tt
NEQ / z : S  =>  True : S

%     LT: Checks that the top of the stack is Less Than zero.

% :: int : 'S   ->   bool : 'S

z < 0
----- :: lt_tt
LT / z : S  =>  True : S

z >= 0
----- :: lt_ff
LT / z : S  =>  False : S

%     GT: Checks that the top of the stack is Greater Than zero.

% :: int : 'S   ->   bool : 'S


z > 0
----- :: gt_tt
GT / z : S  =>  True : S

z <= 0
----- :: gt_ff
GT / z : S  =>  False : S

%     LE: Checks that the top of the stack is Less Than of Equal to zero.

% :: int : 'S   ->   bool : 'S

z <= 0
----- :: le_tt
LE / z : S  =>  True : S

z > 0
----- :: le_ff
LE / z : S  =>  False : S

%     GE: Checks that the top of the stack is Greater Than of Equal to zero.

% :: int : 'S   ->   bool : 'S


z >= 0
----- :: ge
GE / z : S  =>  True : S

z < 0
----- :: lt
GE / z : S  =>  False : S


% V - Operations
% Operations on booleans

%     OR

% :: bool : bool : 'S   ->   bool : 'S

----- :: or1
OR / True : b : S  =>  True : S

----- :: or2
OR / b : True : S  =>  True : S

----- :: or3
OR / False : False : S  =>  False : S

%     AND

% :: bool : bool : 'S   ->   bool : 'S


----- :: and1
AND / True : True : S  =>  True : S

----- :: and2
AND / False : b : S  =>  False : S

----- :: and3
AND / b : False : S  =>  False : S

%     XOR

% :: bool : bool : 'S   ->   bool : 'S

----- :: xor1
XOR / True : True : S  =>  False : S

----- :: xor2
XOR / False : True : S  =>  True : S

----- :: xor3
XOR / True : False : S  =>  True : S

----- :: xor4
XOR / False : False : S  =>  False : S

%     NOT

% :: bool : 'S   ->   bool : 'S

----- :: not1
NOT / True : S  =>  False : S

----- :: not2
NOT / False : S  =>  True : S

% Operations on integers and natural numbers

% Integers and naturals are arbitrary-precision, meaning the only size limit is fuel.

%     NEG

% :: int : 'S   ->   int : 'S
% :: nat : 'S   ->   int : 'S

----- :: neg
NEG / N : S  =>  - N : S

%     ABS

% :: int : 'S   ->   nat : 'S

----- :: abs
ABS / z : S  =>  abs z : S

%     ADD

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: add
ADD / N : N' : S  =>  (N + N') : S

%     SUB

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

----- :: sub
SUB / N : N' : S  =>  ( N - N' ) : S

%     MUL

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: mul
MUL / N : N' : S  =>  ( N * N' ) : S

%     EDIV Perform Euclidian division

% :: int : int : 'S   ->   option (pair int nat) : 'S
% :: int : nat : 'S   ->   option (pair int nat) : 'S
% :: nat : int : 'S   ->   option (pair int nat) : 'S
% :: nat : nat : 'S   ->   option (pair nat nat) : 'S

----- :: ediv_0
EDIV / N : 0 : S  =>  None : S

N' <> 0
----- :: ediv
EDIV / N : N' : S  =>  Some ( Pair ( N / N' ) ( N % N' )) : S

% Bitwise logical operators are also available on unsigned integers.

%     OR

% :: nat : nat : 'S   ->   nat : 'S

----- :: bit_or
OR / n : n' : S  =>  ( n | n' ) : S

%     AND (also available when the top operand is signed)

% :: nat : nat : 'S   ->   nat : 'S
% :: int : nat : 'S   ->   nat : 'S

----- :: bit_and
AND / N : N' : S  =>  ( N & N' ) : S

%     XOR

% :: nat : nat : 'S   ->   nat : 'S

----- :: bit_xor
XOR / n : n' : S  =>  ( n ^ n' ) : S

%     Michelson Documentation: NOT The return type of NOT is an int and not a nat. This is because the sign is also negated. The resulting integer is computed using two’s complement. For instance, the boolean negation of 0 is -1. To get a natural back, a possibility is to use AND with an unsigned mask afterwards.

% :: nat : 'S   ->   int : 'S
% :: int : 'S   ->   int : 'S

----- :: bit_not
NOT / N : S  =>  ~ N : S

%     LSL

% :: nat : nat : 'S   ->   nat : 'S

n' <= 256n
----- :: lsl
LSL / n : n' : S  =>  ( n << n' ) : S

n' > 256n
----- :: lsl_fail
LSL / n : n' : S  =>  [FAILED]

%     LSR

% :: Nat : nat : 'S   ->   nat : 'S

----- :: lsr
LSR / n : n' : S  =>  ( n >>> n' ) : S

%     COMPARE: Integer/natural comparison

% :: int : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

N < N'
----- :: compare_num_lt
COMPARE / N : N' : S  =>  -1z : S

N = N'
----- :: compare_num_eq
COMPARE / N : N' : S  =>  0 : S

N > N'
----- :: compare_num_gt
COMPARE / N : N' : S  =>  1z : S

% Operations on strings

% Michelson Documentation: Strings are mostly used for naming things without having to rely on external ID databases. They are restricted to the printable subset of 7-bit ASCII, plus some escaped characters (see section on constants). So what can be done is basically use string constants as is, concatenate or splice them, and use them as keys.

%     CONCAT: String concatenation.

% :: string : string : 'S   -> string : 'S

----- :: concat_string
CONCAT / s : t : S  =>  ( s ^ t ) : S

% :: string list : 'S   -> string : 'S

----- :: concat_list_nil
CONCAT / [[]] : S  =>  "" : S

CONCAT / < l > : S  =>  t : S
----- :: concat_list_cons
CONCAT / [[ s ; < l > ]] : S  =>  ( s ^ t ) : S

%     SIZE: number of characters in a string.

% :: string : 'S   ->   nat : 'S

----- :: size_string
SIZE / s : S  =>  ( length s ) : S

%     SLICE: String access.

%         :: nat : nat : string : ‘S -> option string : ‘S




% n: length
% n': offset
n + n' < length s
----- :: slice_some
SLICE / n : n' : s : S => Some ( slice s n n' ) : S

%             where ss is the substring of s at the given offset and of the given length

%                 iff offset and (offset + length) are in bounds

% n: length
% n': offset
n + n' >= length s
----- :: slice
SLICE / n : n' : s : S => None : S

%             iff offset or (offset + length) are out of bounds

%     COMPARE: Lexicographic comparison.

% :: string : string : 'S   ->   int : 'S

s < t
----- :: compare_string_lt
COMPARE / s : t : S  =>  -1z : S

s = t
----- :: compare_string_eq
COMPARE / s : t : S  =>  0 : S

s > t
----- :: compare_string_gt
COMPARE / s : t : S  =>  1z : S

% Operations on pairs

%     PAIR: Build a pair from the stack’s top two elements.

% :: 'a : 'b : 'S   ->   pair 'a 'b : 'S

----- :: pair
PAIR / d : d' : S  =>  ( Pair d d' ) : S

%     CAR: Access the left part of a pair.

% :: pair 'a _ : 'S   ->   'a : 'S

----- :: car
CAR / ( Pair d d' ) : S  =>  d : S

%     CDR: Access the right part of a pair.

% :: pair _ 'b : 'S   ->   'b : 'S

----- :: cdr
CDR / ( Pair d d' ) : S  =>  d' : S

% Operations on sets

%     EMPTY_SET 'elt: Build a new, empty set for elements of a given type.

%     The 'elt type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S   ->   set 'elt : 'S

----- :: set_empty
EMPTY_SET ty / S  =>  {} : S

%     MEM: Check for the presence of an element in a set.

% :: 'elt : set 'elt : 'S   ->  bool : 'S

----- :: set_mem_empty
MEM / x : {} : S  =>  False : S

COMPARE / x : y : []  =>  1z : []
% AJ: The original rule was:
% MEM / x : v : { < tl > } : S  =>  r : S
% i don't see where the v comes from. i think it is an error. See remarks of README.
MEM / x : set : S   =>  b : S
----- :: set_mem_later
MEM / x : { y ; < set > } : S  =>  b : S

COMPARE / x : y : []  =>  0 : []
----- :: set_mem_found
MEM / x : { y ; < set > } : S  =>  True : S

COMPARE / x : y : []  =>  -1z : []
----- :: set_mem_nexists
MEM / x : { y ; < set > } : S  =>  False : S

%     UPDATE: Inserts or removes an element in a set, replacing a previous value.

% :: 'elt : bool : set 'elt : 'S   ->   set 'elt : 'S

----- :: set_update_false
UPDATE / x : False : {} : S  =>  {} : S

----- :: set_update_add_nexists
UPDATE / x : True : {} : S  =>  { x } : S

COMPARE / x : d : []  =>  1z : []
UPDATE / x : b : set : S  =>  set' : S
----- :: set_update_cont
UPDATE / x : b : { y ; < set > } : S  =>  { y ; < set' > } : S

COMPARE / x : y : []  =>  0 : []
----- :: set_update_remove
UPDATE / x : False : { y ; < set > } : S  =>  set : S

COMPARE / x : y : []  =>  0 : []
----- :: set_update_exists
UPDATE / x : True : { y ; < set > } : S  =>  { y ; < set > } : S

COMPARE / x : y : []  =>  -1z : []
----- :: set_update_remove_nexists
UPDATE / x : False : { y ; < set > } : S  =>  { y ; < set > } : S

COMPARE / x : y : []  =>  -1z : []
----- :: set_update_add
%% AJ: not sure how to get around the ugliness of the conclusion here
UPDATE / x : True : { y ; < set > } : S  =>  { x ; { y ; < set > } } : S

%     ITER body: Apply the body expression to each element of a set. The body sequence has access to the stack.

% :: (set 'elt) : 'A   ->  'A
%    iff body :: [ 'elt : 'A -> 'A ]

----- :: set_iter_nil
ITER body / {} : S  =>  S

body ; ITER body / hd : < set > : S => S'
----- :: set_iter_cons
ITER body / { hd ; < set > } : S  => S'

%     SIZE: Get the cardinality of the set.

% :: set 'elt : 'S -> nat : 'S

----- :: set_size_nil
SIZE / {} : S  =>  0n : S

SIZE / { < set > } : S  =>  n : S
----- :: set_size_cons
SIZE / { d ; < set > } : S  =>  1n + n : S

% Operations on maps

%     EMPTY_MAP 'key 'val: Build a new, empty map from keys of a given type to values of another given type.

%     The 'key type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S -> map 'key 'val : 'S

----- :: map_empty
EMPTY_MAP ct ty / S  =>  [] : S

%     GET: Access an element in a map, returns an optional value to be checked with IF_SOME.

% :: 'key : map 'key 'val : 'S   ->   option 'val : 'S

----- :: get_empty
GET / x : [] : S  =>  None : S

COMPARE / x : k : []  =>  1z : []
GET / x : < map >  : S  =>  opt_y : S
----- :: get_later
GET / x : [ Elt k v ; < map > ] : S  =>  opt_y : S

COMPARE / x : k : []  =>  0 : []
----- :: get_now
GET / x : [ Elt k v ; < map > ] : S  =>  Some v : S

COMPARE / x : k : []  =>  -1z : []
----- :: get_nexists
GET / x : [ Elt k v ; < map > ] : S  =>  None : S

%     MEM: Check for the presence of a binding for a key in a map.

% :: 'key : map 'key 'val : 'S   ->  bool : 'S

----- :: map_mem_empty
MEM / x : [] : S  =>  False : S

COMPARE / x : k : []  =>  1z : []
MEM / x : < map > : S  =>  r : S
----- :: map_mem_later
MEM / x : [ Elt k v ; < map > ] : S  =>  r : S

COMPARE / x : k : []  =>  0 : []
----- :: map_mem_now
MEM / x : [ Elt k v ; < map > ] : S  =>  True : S

COMPARE / x : k : []  =>  -1z : []
----- :: map_mem_nexists
MEM / x : [ Elt k v ; < map > ] : S  =>  False : S

%     UPDATE: Assign or remove an element in a map.

% :: 'key : option 'val : map 'key 'val : 'S   ->   map 'key 'val : 'S

----- :: map_update_false
UPDATE / x : None : [] : S  =>  [] : S

----- :: map_update_add_nexists
UPDATE / x : Some y : [] : S  =>  [ Elt x y ] : S

COMPARE / x : k : []  =>  1z : []
UPDATE / x : opt_y : < map > : S  =>  < map' > : S
----- :: map_update_cont
UPDATE / x : opt_y : [ Elt k v ; < map > ] : S  =>  [ Elt k v ; < map' > ] : S

COMPARE / x : k : []  =>  0 : []
----- :: map_update_remove
UPDATE / x : None : [ Elt k v ; < map > ] : S  =>  < map > : S

COMPARE / x : k : []  =>  0 : []
----- :: map_update_exists
UPDATE / x : Some y : [ Elt k v ; < map > ] : S  =>  [ Elt k y ; < map > ] : S

COMPARE / x : k : []  =>  -1z : []
----- :: map_update_remove_nexists
UPDATE / x : None : [ Elt k v ; < map > ] : S  =>  [ Elt k v ; < map > ] : S

COMPARE / x : k : []  =>  -1z : []
----- :: map_update_add
UPDATE / x : Some y : [ Elt k v ; < map > ] : S  =>  [ Elt x y ; [ Elt k v ; < map > ]  ] : S

%     MAP body: Apply the body expression to each element of a map. The body sequence has access to the stack.

% :: (map 'key 'val) : 'A   ->  (map 'key 'b) : 'A
%    iff   body :: [ (pair 'key 'val) : 'A -> 'b : 'A ]

----- :: map_map_nil
MAP body / [] : S  =>  [] : S

%% AJ: I'm unsure how to read the conclusion of the original version
%% of this rule.  what is the meaning of applying body to (Pair k v) ?
%% This is how I interpret it.
body / k : v : S => v' : S
MAP body / < map > : S  =>   < map' >  : S
----- :: map_map_cons
MAP body / [ Elt k v ; < map > ] : S  =>  [ Elt k v' ; < map' > ] : S

%     ITER body: Apply the body expression to each element of a map. The body sequence has access to the stack.

% :: (map 'elt 'val) : 'A   ->  'A
%    iff   body :: [ (pair 'elt 'val) : 'A -> 'A ]

----- :: map_iter_nil
ITER body / [] : S  =>  S

body ; ITER body / (Pair k v) : < map > : S => S'
----- :: map_iter_cons
ITER body / [ Elt k v ; < map > ] : S  => S'

%     SIZE: Get the cardinality of the map.

% :: map 'key 'val : 'S -> nat : 'S

----- :: map_size_nil
SIZE / [] : S  =>  0n : S

SIZE / < map > : S  =>  n : S
----- :: map_size_cons
SIZE / [ Elt d d' ; < map > ] : S  =>  1n + n : S

% Operations on big_maps

% AJ: I ignore these.

% The behavior of these operations is the same as if they were normal maps, except that under the hood, the elements are loaded and deserialized on demand.

%     GET: Access an element in a big_map, returns an optional value to be checked with IF_SOME.

% :: 'key : big_map 'key 'val : 'S   ->   option 'val : 'S

%     MEM: Check for the presence of an element in a big_map.

% :: 'key : big_map 'key 'val : 'S   ->  bool : 'S

%     UPDATE: Assign or remove an element in a big_map.

% :: 'key : option 'val : big_map 'key 'val : 'S   ->   big_map 'key 'val : 'S

%%
%% Operations on optional values
%%

%     SOME: Pack a present optional value.

% :: 'a : 'S   ->   option 'a : 'S

----- :: some
SOME / v : S  =>  (Some v) : S

%     NONE 'a: The absent optional value.

% :: 'S   ->   option 'a : 'S

----- :: none
NONE ty / v : S  =>  None : S

%     IF_NONE bt bf: Inspect an optional value.

% :: option 'a : 'S   ->   'b : 'S
%    iff   bt :: [ 'S -> 'b : 'S]
%          bf :: [ 'a : 'S -> 'b : 'S]

bt / S => S'
----- :: if_none
IF_NONE bt bf / None : S => S'

bf / d : S => S'
----- :: if_some
IF_NONE bt bf / (Some d) : S =>  S'

% Operations on unions

%     LEFT 'b: Pack a value in a union (left case).

% :: 'a : 'S   ->   or 'a 'b : 'S

----- :: pack_left
LEFT ty / v : S  =>  (Left v) : S

%     RIGHT 'a: Pack a value in a union (right case).

% :: 'b : 'S   ->   or 'a 'b : 'S

----- :: pack_right
RIGHT ty / v : S  =>  (Right v) : S

%     IF_LEFT bt bf: Inspect a value of a variant type.

% :: or 'a 'b : 'S   ->   'c : 'S
%    iff   bt :: [ 'a : 'S -> 'c : 'S]
%          bf :: [ 'b : 'S -> 'c : 'S]

bt / d : S => S'
----- :: if_left_left
IF_LEFT bt bf / (Left d) : S  =>  S'

bf / d : S => S'
----- :: if_left_right
IF_LEFT bt bf / (Right d) : S  => S'

%     IF_RIGHT bt bf: Inspect a value of a variant type.

% :: or 'a 'b : 'S   ->   'c : 'S
%    iff   bt :: [ 'b : 'S -> 'c : 'S]
%          bf :: [ 'a : 'S -> 'c : 'S]

bt / d : S => S'
----- :: if_right_right
IF_RIGHT bt bf / (Right d) : S  => S'

bf / d : S => S'
----- :: if_right_left
IF_RIGHT bt bf / (Left d) : S  =>  S'

% Operations on lists

%     CONS: Prepend an element to a list.

% :: 'a : list 'a : 'S   ->   list 'a : 'S

----- :: cons
CONS / d : < l >  : S  =>  [[ d ; < l > ]] : S

%     NIL 'a: The empty list.

% :: 'S   ->   list 'a : 'S

----- :: nil
NIL ty / S  => [[]] : S

%     IF_CONS bt bf: Inspect an optional value.

% :: list 'a : 'S   ->   'b : 'S
%    iff   bt :: [ 'a : list 'a : 'S -> 'b : 'S]
%          bf :: [ 'S -> 'b : 'S]

bt / d : < l > : S => S'
----- :: if_cons_cons
IF_CONS bt bf / [[ d ; < l > ]]  : S  => S'

bf / S => S'
----- :: if_cons_nil
IF_CONS bt bf / [[]] : S  =>  S'

%     MAP body: Apply the body expression to each element of the list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  (list 'b) : 'A
%    iff   body :: [ 'elt : 'A -> 'b : 'A ]

body / d : S => d' : S
MAP body /  < l >  : S  =>   < l' >  : S
----- :: list_map_cons
MAP body / [[ d ; < l > ]]  : S  =>  [[ d' ; < l' > ]] : S

----- :: list_map_nil
MAP body / {} : S  =>  {} : S

%     SIZE: Get the number of elements in the list.

% :: list 'elt : 'S -> nat : 'S

SIZE / < l >  : S  =>  n : S
----- :: list_size_cons
SIZE / [[ d ; <l> ]] : S  =>  1n + n : S

----- :: list_size_nil
SIZE / {} : S  =>  0n : S

%     ITER body: Apply the body expression to each element of a list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  'A
%      iff body :: [ 'elt : 'A -> 'A ]

body ; ITER body / d : <l>  : S => S'
----- :: list_iter_cons
ITER body / [[ d ; <l> ]] : S  =>  S'

----- :: list_iter_nil
ITER body / {} : S  =>  S




embed {{coq
End syntax.
}}
