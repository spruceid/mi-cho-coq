Copyright Arvid Jakobsson 2018


Table of Contents
_________________

1 Files
2 Compiling
.. 2.1 Pre-requisites
.. 2.2 Generating Coq file
.. 2.3 Generating Typeset file
3 The ott file
4 Limitations
5 The typeset rules
6 The generated Coq file
.. 6.1 Tests
7 Interpreter
8 What to do next
9 Remarks on the original semantics


1 Files
=======

  - michelson.ott: (commented) ott definition of michelson.
  - michelson.v: coq definition of michelson, as generated by ott
  - Formulas.v: hand-written coq definition of some formulas
    (e.g. arithmetic functions) needed by generated coq definition of
    michelson.
  - michelson.tex: typeset version of michelson, as generated by ott

  Extras:

  - michelson-extract.v: Coq code and proofs for extracting executable
  - michelson-tests.v: Example derivation for some small michelson
    programs.  michelson interpreter.
  - michelson.ml: ocaml interpreter extracted from Coq definition. See
    section "Interpreter" for more info.
  - michelson-aexp.v: A certified mini-compiler of a arithmetic
    mini-expression language.  to michelson.
  - README: this file ;)


2 Compiling
===========

2.1 Pre-requisites
~~~~~~~~~~~~~~~~~~

  To re-generate (the already included) michelson.v, ott is needed,
  which can be installed by running:

  $ opam install ott coq-ott

  To compile the generated proof assistant code, coq is needed, which
  can be installed by running:

  $ opam install coq


2.2 Generating Coq file
~~~~~~~~~~~~~~~~~~~~~~~

  To regenerate the proof assistant code, run:

  $ make michelson.v


2.3 Generating Typeset file
~~~~~~~~~~~~~~~~~~~~~~~~~~~

  To regenerate the proof assistant code, run:

  $ make michelson.pdf


3 The ott file
==============

  The ott file `michelson.ott' contains the specification of the ott
  language/data grammar and big-step semantics. The file is divided in
  three sections: 1. Grammar, 2. Formulas and 3. Inference rules. I've
  commented this file, and the interested reader can refer to it for
  more information on how I model michelson, how the ott definitions are
  written, how they're translated to proof assistant code.

  As a small example, the rule add:

  ,----
  | ----- :: add
  | ADD / N : N' : S  =>  (N + N') : S
  `----

  This ott code specifies the rule "add".  This rule applies when the
  current instruction is ADD and two numerals N and N' (int or nat) are
  on the stack. The resulting stack contains the sum of two
  numerals. The meaning of "+" is given by the coq extraction.

  The ott code is very close to the existing ASCII formalization. This
  enables, for instance, using the definitions of the semantics both as
  actual implementation and in the documentation.


4 Limitations
=============

  I've made no attempt to implement the typing rules. Hence, the
  semantics can execute programs that are ill-typed, for instance by
  creating a data_list that contains values of different types (see
  example `ill_typed' in michelson-tests.v). In other cases, the
  semantics is simply not defined for ill-typed (see example
  `ill_typed2').

  I've also not implemented big maps, due to their similarity to maps,
  nor the domain specific operations.

  I've demonstrated how the ott definition can be extracted to
  Coq. However, the ott does not fix the implementation of operations on
  basic data-types such as integers etc. Instead, the user specifies how
  ott formulas should be translated to coq. For instance, michelson
  strings are translated to coq strings, and the slice function of
  michelson is translated to the coq substring function. I have not
  completed this translation due to lack of time. See for instance ott
  grammar for num, and how arithmetic functions on nums are (partially)
  implemented in `num_apply_aop' in `Formulas.v'.

  As a result the extracted coq definition cannot yet give the meaning
  of all michelson programs, however, a majority of the inference rules
  are implemented.


5 The typeset rules
===================

  The ott definitions is automatically typeset by ott in
  `michelson.pdf'. I've made little attempt to improve the typesetting,
  but the type-setting of ott can be heavily customized.


6 The generated Coq file
========================

  The ott definitions are translated into Coq code in
  `michelson.v'. This file contains the inductive data types
  corresponding to data and instructions. One common complaint against
  ott is that the generated relations, such as `big_step' here, are
  ugly. In this case however, I think the definitions is quite readable
  considering their size, and the situation could be improved by
  introducing custom Coq notation.


6.1 Tests
~~~~~~~~~

  The file `michelson-tests.v' contains a few example derivations of
  program executions.


7 Interpreter
=============

  I have started work on deriving an OCaml interpreter that can be
  tested against other michelson implementations. This can be done by
  proving that the coq big-step relation is a total function, which
  allows to extract it as a OCaml function. See `michelson-extract.v'
  for the initial work in this direction and `michelson.ml' the extract
  interpreter. I've proved the rules for push, add, sub and
  sequence. Some further mechanism is needed to handle looping programs,
  since Coq does not allow writing non-terminating functions (like the
  interpreter for an non-terminating program). Typically, one writes an
  interpreter that is allowed to execute a maximum number of steps.

  An parser would also need to be implemented.


8 What to do next
=================

  - Continue implementing the missing basic data operations for the Coq
    extraction.
  - The semantics would need more testing to verify that it actually
    follows the intent of the semi-formal semantics of the michelson
    documentation.
  - As mentioned, there is an existing, hand-written, Coq formalization
    of michelson. It would be interesting to compare that one and the
    one generated by Ott.


9 Remarks on the original semantics
===================================

  I made some notes while reading the michelson formalization in the
  documentation.

  - I think there is an error in the rule GT: what is C?
  - EDIV, SIZE, SLICE, IF_RIGHT are not in grammar of instructions
  - SIZE for strings is missing a rule in the semantics?
  - Sometimes boolean constants are written e.g. false, sometimes False.
  - Sets are missing from data (unless they are seen as lists?)
  - I was unsure how to treat the map instruction. How to interpret the
    conclusion where an instruction is applied to data, while having
    access (read/write only?) to the stack? I interpret this as the body
    being executed in the initial stack, with the key and value on top,
    and that it does not have the right to modify the underlying
    stack. I.e:

  ,----
  | body / k : v : S => v' : S
  | MAP body / < map > : S  =>   < map' >  : S
  | ----- :: map_map_cons
  | MAP body / [ Elt k v ; < map > ] : S  =>  [ Elt k v' ; < map' > ] : S
  `----

  - Missing type variable in rules of NONE, LEFT, RIGHT, NIL
  - There is a meta-variable "v" in rules for MEM which does not seem to
    be bound to anything, I think this is an error.
