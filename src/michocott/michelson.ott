embed {{ coq
Require Import String.
Require Import ZArith.
Open Scope string_scope.

Module Mutez.
  Inductive mutez :=.
End Mutez.
}}

metavar nat_litteral ::= {{ coq N }}
metavar int_litteral ::= {{ coq Z }}
metavar string_litteral ::= {{ coq String.string }}
metavar timestamp_litteral ::= {{ coq Z }}
metavar signature_litteral ::= {{ coq String.string }}
metavar key_litteral ::= {{ coq String.string }}
metavar key_hash_litteral ::= {{ coq String.string }}
metavar mutez_litteral ::= {{ coq Mutez.mutez }}
metavar contract_litteral ::= {{ coq String.string }}

indexvar N ::= {{ coq nat }}

grammar

%% Operators

bop :: 'bop_' ::= {{ coq bool -> bool -> bool }} {{ phantom }}
    | || :: :: Or {{ coq orb }}
    | && :: :: And {{ coq andb }}
    | xor :: :: Xor {{ coq xorb }}

aop :: 'aop_' ::=
    | + :: :: Add
    | - :: :: Sub
    | * :: :: Mul
    | / :: :: Div
    | % :: :: Mod
    | << :: :: Lsl
    | >> :: :: Lsr

bitop :: 'bitop_' ::=
    | | :: :: Or
    | & :: :: And
    | ^ :: :: Xor

%% Data litterals

nat_lit, n :: 'n_' ::= {{ coq nat }} {{ phantom }}
  | 0 :: M :: NatZero {{ coq 0 }}
  | 1 :: M :: NatOne {{ coq 1 }}
  | 256 :: M :: NatMaxByte {{ coq 256 }}
  | length s :: M :: StringLength {{ coq (String.length s) }}
  | abs z :: M :: Abs {{ coq (Z.abs_nat [[z]]) }}

int_lit, z :: 'z_' ::= {{ coq Z }} {{ phantom }}
  | 0 :: M :: IntZero {{ coq 0 }}
  | 1 :: M :: IntOne {{ coq 1 }}

num, nz :: 'num_' ::=
  | int_lit :: :: IntConstant
  | nat_lit :: :: NatConstant
  | nz1 aop nz2 :: M :: Aop {{ coq ( num_apply_aop [[aop]] [[nz1]] [[nz2]] ) }}
  | nz1 bitop nz2 :: M :: Bitop {{ coq ( num_apply_bitop [[bitop]] [[nz1]] [[nz2]] ) }}
  | - nz :: M :: NumNeg {{ coq ( num_neg [[nz]] ) }}
  | ~ nz :: M :: BitNeg {{ coq ( num_bit_neg [[nz]] ) }}

string_lit, s , t :: 's_' ::= {{ coq String.string }} {{ phantom }}
     | "" :: M :: StringEmpty {{ coq ("") }}
     | ( s ^ s' ) :: M :: Concat {{ coq (String.append [[s]] [[s']]) }}
     | slice s n1 n2 :: M :: StringSlice {{ coq (String.substring [[n1]] [[n2]] [[s]]) }}

bool_lit, b :: 'b_' ::= {{ coq bool }} {{ phantom }}
     | True :: M :: True {{ coq true }}
     | False :: M :: False {{ coq false }}
     | ( b1 bop b2 ) :: M :: Bop {{ coq ( [[bop]] [[b1]] [[b2]] ) }}
     | ! b2  :: M :: Neg {{ coq ( negb [[b2]] ) }}

set_or_list, tl :: 'setlist_' ::= {{ coq list data }} {{ phantom }}
     | {} :: M :: Nil {{ coq nil }}
     | { d ; tl } :: M :: Cons {{ coq ([[d]] :: [[tl]])  }}
     %% meta-productions
     | { d }  :: M :: Singleton {{ coq ([[d]] :: nil)  }}
     | < tl > :: M :: Chevron {{ coq [[tl]] }}

map_elt :: '' ::=
     | Elt k v :: :: Elt

map_lit, m :: 'map_' ::= {{ coq list (data * data) }} {{ phantom }}
     | {} :: M :: Nil {{ coq nil }}
     | { Elt d d' ; m }  :: M :: Cons {{ coq (([[d]], [[d']])::[[m]]) }}
     % meta-productions
     | { Elt d d' }  :: M :: Singleton {{ coq (([[d]], [[d']])::nil) }}
     | < m > :: M :: Chevron {{ coq [[m]] }}
     %| { Elt d1 d1'  ; .. ; Elt dN dN' } :: :: Map


%% Data

data, x, y, k, v, d, opt_y :: d_ ::=
  | num :: :: Num
  | string_lit :: :: StringConstant
  | bool_lit :: :: Bool
  | timestamp_litteral :: :: Timestamp
  | signature_litteral :: :: Signature
  | key_litteral :: :: Key
  | key_hash_litteral :: :: Key_hash
  | mutez_litteral :: :: Mutez
  | contract_litteral :: :: Contract
  | Unit :: :: Unit
  | Pair x y :: :: Pair
  | Left x :: :: Left
  | Right y :: :: Right
  | Some x :: :: Some
  | None :: :: None
  | set_or_list :: :: SetList
  | map_lit :: :: Map
  | code :: :: instruction
  | 0 :: M :: zero {{ coq data_int 0%Z}}

  | ( data ) :: M :: Paren {{ coq ( [[data]] ) }}

%% Types

comparable_type, kty, cty :: cty_ ::=
  | string    :: :: string
  | nat       :: :: nat
  | int       :: :: int
  | bytes     :: :: bytes
  | bool      :: :: bool
  | mutez     :: :: mutez
  | key_hash  :: :: key_hash
  | timestamp :: :: timestamp

type, ty, vty :: ty_ ::=
  | cty             :: :: Comparable_type
  | key             :: :: key
  | unit            :: :: unit
  | signature       :: :: signature
  | option type     :: :: option
  | list type       :: :: list
  | set cty           :: :: set
  | contract type   :: :: contract
  | address         :: :: address
  | operation       :: :: operation
  | pair ty1 ty2        :: :: pair
  | or ty1 ty2          :: :: or
  | lambda ty1 ty2      :: :: lambda
  | map kty vty     :: :: map
  | big_map kty vty :: :: big_map
  | self_ty         :: M :: self_ty {{coq self_ty}}
  | ( ty1 )           :: M :: parens {{coq ([[ty1]])}}

%% Operations

comparison :: 'i_' ::=
  | EQ :: :: EQ
  | NEQ :: :: NEQ
  | LT :: :: LT
  | GT :: :: GT
  | LE :: :: LE
  | GE :: :: GE

binary_bitwise :: 'i_' ::=
  | OR :: :: OR
  | AND :: :: AND
  | XOR :: :: XOR

hash_function :: 'i_' ::=
  | HASH_KEY :: :: HASH_KEY
  | BLAKE2B :: :: BLAKE2B
  | SHA256 :: :: SHA256
  | SHA512 :: :: SHA512

%% Instructions


function :: 'i_' ::=
  | PUSH ty1 x :: :: PUSH
  | UNIT :: :: UNIT
  | LAMBDA ty1 ty2 code :: :: LAMBDA
  | EMPTY_SET cty :: :: EMPTY_SET
  | EMPTY_MAP kty vty :: :: EMPTY_MAP
  | NONE ty1 :: :: NONE
  | NIL ty1 :: :: NIL
  | BALANCE :: :: BALANCE
  | SOURCE :: :: SOURCE
  | SENDER :: :: SENDER
  | SELF :: :: SELF
  | AMOUNT :: :: AMOUNT
  | STEPS_TO_QUOTA :: :: STEPS_TO_QUOTA
  | NOW :: :: NOW

  | comparison :: :: unary_comparison
  | hash_function :: :: unary_hash
  | NOT :: :: NOT
  | NEG :: :: NEG
  | ABS :: :: ABS
  | SIZE :: :: SIZE
  | CAR :: :: CAR
  | CDR :: :: CDR
  | SOME :: :: SOME
  | LEFT ty2 :: :: LEFT
  | RIGHT ty1 :: :: RIGHT
  | ADDRESS :: :: ADDRESS
  | CONTRACT ty :: :: CONTRACT
  | SET_DELEGATE :: :: SET_DELEGATE
  | IMPLICIT_ACCOUNT :: :: IMPLICIT_ACCOUNT
  | PACK :: :: PACK
  | UNPACK ty1 :: :: UNPACK

  | binary_bitwise :: :: b_bitwise
  | EXEC :: :: EXEC
  | LSL :: :: LSL
  | LSR :: :: LSR
  | COMPARE :: :: COMPARE
  | CONCAT :: :: CONCAT
  | PAIR :: :: PAIR
  | MEM :: :: MEM
  | GET :: :: GET
  | CONS :: :: CONS

  | DROP :: :: DROP
  | DUP :: :: DUP
  | SWAP :: :: SWAP

  | SLICE :: :: SLICE
  | UPDATE :: :: UPDATE
  | CREATE_ACCOUNT :: :: CREATE_ACCOUNT
  | TRANSFER_TOKENS :: :: TRANSFER_TOKENS
  | CHECK_SIGNATURE :: :: CHECK_SIGNATURE

  | ADD :: :: ADD
  | SUB :: :: SUB
  | MUL :: :: MUL
  | EDIV :: :: EDIV

%% Code

code, i, body :: 'i_' ::=
  | function :: :: Fun
  | FAILWITH :: :: FAILWITH
  | {} :: :: NOOP
  | code1 ; code2 :: :: SEQ
  | IF code1 code2 :: :: IF
  | LOOP code :: :: LOOP
  | LOOP_LEFT code :: :: LOOP_LEFT
  | DIP code :: :: DIP
  | ITER code :: :: ITER
  | MAP code :: :: MAP
  | IF_NONE code1 code2 :: :: IF_NONE
  | IF_LEFT code1 code2 :: :: IF_LEFT
  | IF_RIGHT code1 code2 :: :: IF_RIGHT
  | IF_CONS code1 code2 :: :: IF_CONS
  | CREATE_CONTRACT code :: :: CREATE_CONTRACT

%% Stack

stack, st, S :: Stack_ ::= {{coq list data }} {{ phantom }}
  | [] :: M :: empty {{ coq nil }}
  | d : S :: M :: cons {{ coq ([[d]] :: [[S]]) }}

stack_type, A, B, C :: Stack_type_ ::= {{ coq Datatypes.list type }} {{ phantom }}
  | [] :: :: empty {{ coq nil}}
  | ty1 ':' A :: :: cons {{ coq (cons[[ty1]][[A]])}}
  | A @ B :: M :: append {{ coq (List.app[[A]][[B]])}}

% A stackerr is either failed or a stack, which is a list of data.
stackerr, SE :: 'SE_' ::=
       | [FAILED] :: :: Failed
       | stack :: :: Stack

%% Formulas

formula :: formula_ ::=
  | judgement :: :: judgement
  | formula1 .. formulaN :: :: dots
  | get_contract_type contract_litteral ty :: M :: get_contract_rel
    {{ coq get_contract_rel [[contract_litteral]] [[ty]] }}
  | x = y :: M :: eq {{coq (compare [[x]] i_EQ [[y]])}}
  | x <> y :: M :: neq {{coq (compare [[x]] i_NEQ [[y]])}}
  | x < y :: M :: lt {{coq (compare [[x]] i_LT [[y]])}}
  | x > y :: M :: gt {{coq (compare [[x]] i_GT [[y]])}}
  | x <= y :: M :: le {{coq (compare [[x]] i_LE [[y]])}}
  | x >= y :: M :: ge {{coq (compare [[x]] i_GE [[y]])}}

embed {{coq
Section syntax.
  Variable self_ty : type.
  Variable get_contract_rel : String.string -> type -> Prop.
}}

embed {{ coq
Load Formulas.
}}


defns
Typing :: 't_' ::=

  defn
  x '::' ty :: :: data_has_type :: 'data_' by

       ------------------ :: int
       int_lit :: int

       ------------------ :: nat
       nat_lit :: nat

       ------------------------ :: string
       string_lit :: string

       ------------------------------ :: timestamp
       timestamp_litteral :: timestamp

       ------------------------------ :: signature
       signature_litteral :: signature

       ------------------ :: key
       key_litteral :: key

       ---------------------------- :: key_hash
       key_hash_litteral :: key_hash

       ---------------------- :: mutez
       mutez_litteral :: mutez

       get_contract_type contract_litteral ty1
       ------------------------------------- :: contract
       contract_litteral :: contract ty1

       ----------- :: Unit
       Unit :: unit

       ----------- :: bool
       bool_lit :: bool

       x :: ty1
       y :: ty2
       ------------------- :: Pair
       Pair x y :: pair ty1 ty2

       x :: ty1
       --------------- :: Left
       Left x :: or ty1 ty2

       y :: ty2
       ---------------- :: Right
       Right y :: or ty1 ty2

       x :: ty1
       ----------------- :: Some
       Some x :: option ty1

       --------------- :: None
       None :: option ty1

       ------------------------ :: set_empty
       :setlist_Nil: {} :: set cty

       x :: cty
       tl :: set cty
       ------------------------ :: set_cons
       { x ; <tl> } :: set cty

       ------------------------ :: list_empty
       :setlist_Nil: {} :: list cty

       x :: cty
       tl :: list cty
       ------------------------ :: list_cons
       { x ; <tl> } :: list cty

       ------------------------ :: map_empty
       :map_Nil: {} :: map kty vty

       x :: kty
       y :: vty
       m :: map kty vty
       ------------------------ :: map_cons
       { Elt x y ; <m> } :: map kty vty

       code :: ty1 : [] => ty2 : []
       ------------------------- :: instruction
       code :: lambda ty1 ty2

  defn
  map_elt '::' kty, vty :: :: map_elt_has_type :: 'map_elt_' by

       k :: kty
       v :: vty
       ------------------ :: map_elt
       Elt k v :: kty, vty


  defn
  function '::' A -> B :: :: fun_has_type :: 'instr_' by

       x :: ty1
       ---------------------------- :: PUSH
       PUSH ty1 x :: [] -> ty1 : []

       ----------------------- :: UNIT
       UNIT :: [] -> unit : []

       code :: ty1 : [] => ty2 : []
       ------------------------------------------------ :: LAMBDA
       LAMBDA ty1 ty2 code :: [] -> lambda ty1 ty2 : []

       ----------------------------------- :: EMPTY_SET
       EMPTY_SET cty :: [] -> set cty : []

       ------------------------------------------- :: EMPTY_MAP
       EMPTY_MAP kty vty :: [] -> map kty vty : []

       --------------------------------- :: NONE
       NONE ty1 :: [] -> option ty1 : []

       ------------------------------ :: NIL
       NIL ty1 :: [] -> list ty1 : []

       --------------------------- :: BALANCE
       BALANCE :: [] -> mutez : []

       ---------------------------- :: SOURCE
       SOURCE :: [] -> address : []

       ---------------------------- :: SENDER
       SENDER :: [] -> address : []

       -------------------------- :: SELF
       SELF :: [] -> self_ty : []

       -------------------------- :: AMOUNT
       AMOUNT :: [] -> mutez : []

       -------------------------------- :: STEPS_TO_QUOTA
       STEPS_TO_QUOTA :: [] -> nat : []

       --------------------------- :: NOW
       NOW :: [] -> timestamp : []

       ----------------------------------- :: comparison
       comparison :: int : [] -> bool : []

       ----------------------------- :: NOT__bool
       NOT :: bool : [] -> bool : []

       --------------------------- :: NOT__nat
       NOT :: nat : [] -> int : []

       --------------------------- :: NOT__int
       NOT :: int : [] -> int : []

       --------------------------- :: NEG__nat
       NEG :: nat : [] -> int : []

       --------------------------- :: NEG__int
       NEG :: int : [] -> int : []

       --------------------------- :: ABS
       ABS :: int : [] -> nat : []

       -------------------------------- :: SIZE__set
       SIZE :: set cty : [] -> nat : []

       ------------------------------------ :: SIZE__map
       SIZE :: map kty vty : [] -> nat : []

       ------------------------------- :: SIZE__list
       SIZE :: list ty1 : [] -> nat : []

       ------------------------------- :: SIZE__string
       SIZE :: string : [] -> nat : []

       ------------------------------ :: SIZE__bytes
       SIZE :: bytes : [] -> nat : []

       ------------------------------ :: CAR
       CAR :: pair ty1 ty2 : [] -> ty1 : []

       ------------------------------ :: CDR
       CDR :: pair ty1 ty2 : [] -> ty2 : []

       ------------------------------- :: SOME
       SOME :: ty1 : [] -> option ty1 : []

       ------------------------------- :: LEFT
       LEFT ty2 :: ty1 : [] -> or ty1 ty2 : []

       -------------------------------- :: RIGHT
       RIGHT ty1 :: ty2 : [] -> or ty1 ty2 : []

       ------------------------------------------ :: ADDRESS
       ADDRESS :: contract ty1 : [] -> address : []

       --------------------------------------------- :: CONTRACT
       CONTRACT ty1 :: address : [] -> contract ty1 : []

       ------------------------------------------------------ :: SET_DELEGATE
       SET_DELEGATE :: option key_hash : [] -> operation : []

       ------------------------------------------------------- :: IMPLICIT_ACCOUNT
       IMPLICIT_ACCOUNT :: key_hash : [] -> contract unit : []

       ---------------------------- :: PACK
       PACK :: ty1 : [] -> bytes : []

       -------------------------------- :: UNPACK
       UNPACK ty1 :: bytes : [] -> ty1 : []

       ------------------------------------- :: HASH_KEY
       HASH_KEY :: key : [] -> key_hash : []

       ----------------------------------------- :: HASH
       hash_function :: bytes : [] -> bytes : []

       ----------------------------------------------- :: bitwise_bool
       binary_bitwise :: bool : bool : [] -> bool : []

       -------------------------------------------- :: bitwise_nat
       binary_bitwise :: nat : nat : [] -> nat : []

       --------------------------------------------- :: EXEC
       EXEC :: ty1 : lambda ty1 ty2 : [] -> ty2 : []

       --------------------------------- :: LSL
       LSL :: nat : nat : [] -> nat : []

       --------------------------------- :: LSR
       LSR :: nat : nat : [] -> nat : []

       --------------------------------- :: COMPARE
       COMPARE :: cty : cty : [] -> int : []

       --------------------------------------------- :: CONCAT__string_list
       CONCAT :: list string : [] -> string : []

       --------------------------------------------- :: CONCAT__string
       CONCAT :: string : string : [] -> string : []

       ------------------------------------------ :: CONCAT__bytes_list
       CONCAT :: bytes : bytes : [] -> bytes : []

       ------------------------------------------ :: CONCAT__bytes
       CONCAT :: list bytes : [] -> bytes : []

       ----------------------------------- :: PAIR
       PAIR :: ty1 : ty2 : [] -> pair ty1 ty2 : []

       ---------------------------------- :: MEM__set
       MEM :: cty : set cty : [] -> bool : []

       ------------------------------------------ :: MEM__map
       MEM :: kty : map kty vty : [] -> bool : []

       ---------------------------------------------- :: MEM__big_map
       MEM :: kty : big_map kty vty : [] -> bool : []

       ------------------------------------------------ :: GET__map
       GET :: kty : map kty vty : [] -> option vty : []

       ---------------------------------------------------- :: GET__big_map
       GET :: kty : big_map kty vty : [] -> option vty : []

       -------------------------------------------- :: CONS
       CONS :: ty1 : list ty1 : [] -> list ty1 : []

       ---------------------- :: DROP
       DROP :: ty1 : [] -> []

       --------------------------------- :: DUP
       DUP :: ty1 : [] -> ty1 : ty1 : []

       ---------------------------------------- :: SWAP
       SWAP :: ty1 : ty2 : [] -> ty2 : ty1 : []

       ------------------------------------------------------ :: SLICE__string
       SLICE :: nat : nat : string : [] -> option string : []

       ---------------------------------------------------- :: SLICE__bytes
       SLICE :: nat : nat : bytes : [] -> option bytes : []

       --------------------------------------------------- :: UPDATE__set
       UPDATE :: cty : bool : set cty : [] -> set cty : []

       ---------------------------------------------------------- :: UPDATE__map
       UPDATE :: kty : vty : map kty vty : [] -> map kty vty : []

       ------------------------------------------------------------------ :: UPDATE__big_map
       UPDATE :: kty : vty : big_map kty vty : [] -> big_map kty vty : []


------------------------------------------------------------------------------------------------------- :: CREATE_ACCOUNT
       CREATE_ACCOUNT :: key_hash : option key_hash : bool : mutez : [] -> operation : contract unit : []


       ------------------------------------------------------------------- :: TRANSFER_TOKENS
       TRANSFER_TOKENS :: ty1 : mutez : contract ty1 : [] -> operation : []


       --------------------------------------------------------------- :: CHECK_SIGNATURE
       CHECK_SIGNATURE :: key : signature : bytes : [] -> bool : []


       ----------------------------------- :: ADD__nat_nat
       ADD :: nat : nat : [] -> nat : []

       ----------------------------------- :: ADD__nat_int
       ADD :: nat : int : [] -> int : []

       ----------------------------------- :: ADD__int_nat
       ADD :: int : nat : [] -> int : []

       ----------------------------------- :: ADD__int_int
       ADD :: int : int : [] -> int : []

       ----------------------------------------------- :: ADD__timestamp_int
       ADD :: timestamp : int : [] -> timestamp : []

       ----------------------------------------------- :: ADD__int_timestamp
       ADD :: int : timestamp : [] -> timestamp : []

       ----------------------------------------- :: ADD__mutez_mutez_mutez
       ADD :: mutez : mutez : [] -> mutez : []

       ----------------------------------- :: SUB__nat_nat
       SUB :: nat : nat : [] -> int : []

       ----------------------------------- :: SUB__nat_int
       SUB :: nat : int : [] -> int : []

       ----------------------------------- :: SUB__int_nat
       SUB :: int : nat : [] -> int : []

       ----------------------------------- :: SUB__int_int
       SUB :: int : int : [] -> int : []

       ----------------------------------------------- :: SUB__timestamp_int
       SUB :: timestamp : int : [] -> timestamp : []

       ----------------------------------------------- :: SUB__timestamp_timestamp
       SUB :: timestamp : timestamp : [] -> int : []

       ----------------------------------------- :: SUB__mutez_mutez
       SUB :: mutez : mutez : [] -> mutez : []

       ----------------------------------- :: MUL__nat_nat
       MUL :: nat : nat : [] -> nat : []

       ----------------------------------- :: MUL__nat_int
       MUL :: nat : int : [] -> int : []

       ----------------------------------- :: MUL__int_nat
       MUL :: int : nat : [] -> int : []

       ----------------------------------- :: MUL__int_int
       MUL :: int : int : [] -> int : []

       --------------------------------------- :: MUL__mutez_nat
       MUL :: mutez : nat : [] -> mutez : []

       --------------------------------------- :: MUL__nat_mutez
       MUL :: nat : mutez : [] -> mutez : []

       ------------------------------------------- :: EDIV__nat_nat
       EDIV :: nat : nat : [] -> nat : nat : []

       ------------------------------------------- :: EDIV__nat_int
       EDIV :: nat : int : [] -> int : nat : []

       ------------------------------------------- :: EDIV__int_nat
       EDIV :: int : nat : [] -> int : nat : []

       ------------------------------------------- :: EDIV__int_int
       EDIV :: int : int : [] -> int : nat : []

       ------------------------------------------------- :: EDIV__mutez_nat
       EDIV :: mutez : nat : [] -> mutez : mutez : []

       ------------------------------------------------- :: EDIV__mutez_mutez
       EDIV :: mutez : mutez : [] -> nat : mutez : []

  defn
  code '::' A => B :: :: code_has_type :: 'instr_' by

       function :: A -> B
       ------------------------- :: function
       function :: A @ C => B @ C

       ---------------------- :: FAILWITH
       FAILWITH :: ty1 : A => B

       ------------- :: NOOP
       {} :: A => A

       code1 :: A => B
       code2 :: B => C
       ------------------------ :: SEQ
       code1; code2 :: A => C

       code1 :: A => B
       code2 :: A => B
       ------------------------------- :: IF
       IF code1 code2 :: bool : A => B

       code :: A => bool : A
       -------------------------- :: LOOP
       LOOP code :: bool : A => A

       code :: ty1 : A => or ty1 ty2 : A
       --------------------------------- :: LOOP_LEFT
       LOOP_LEFT code :: or ty1 ty2 : A => A

       code :: A => B
       --------------------------- :: DIP
       DIP code :: ty1 : A => ty1 : B

       code :: ty1 : A => A
       ---------------------------- :: ITER__list
       ITER code :: list ty1 : A => A

       code :: cty : A => A
       ---------------------------- :: ITER__set
       ITER code :: set cty : A => A

       code :: (pair kty vty) : A => A
       --------------------------------- :: ITER__map
       ITER code :: map kty vty : A => A

       code :: ty1 : A => ty2 : A
       ------------------------------------- :: MAP__list
       MAP code :: list ty1 : A => list ty2 : A

       code :: (pair kty ty1) : A => ty2 : A
       ------------------------------------------- :: MAP__map
       MAP code :: map kty ty1 : A => map kty ty2 : A

       code1 :: A => B
       code2 :: ty1 : A => B
       ---------------------------------------- :: IF_NONE
       IF_NONE code1 code2 :: option ty1 : A => B

       code1 :: ty1 : A => B
       code2 :: ty2 : A => B
       -------------------------------------- :: IF_LEFT
       IF_LEFT code1 code2 :: or ty1 ty2 : A => B

       code1 :: ty2 : A => B
       code2 :: ty1 : A => B
       -------------------------------------- :: IF_RIGHT
       IF_RIGHT code1 code2 :: or ty1 ty2 : A => B

       code1 :: ty1 : list ty1 : A => B
       code2 :: A => B
       -------------------------------------- :: IF_CONS
       IF_CONS code1 code2 :: list ty1 : A => B

-------------------------------------------------------------------------------------------------------------------- :: CREATE_CONTRACT
       CREATE_CONTRACT code :: key_hash : option key_hash : bool : bool : mutez : ty2 : A => operation : address : A

defns
BigStep :: '' ::=


%% A big-step goes from an instruction (which is possible a sequence
%% of instructions), an initial stack to a final stack.

% Local big-step rules
defn
i / stackerr => stackerr'  :: :: BigStep :: 'bs_'
{{ tex [[i]] / [[stackerr]] \Rightarrow [[stackerr']] }}
by


%%
%% Now follows the rules. As far as possible, I follow the look of the
%% rules in the Michelson documentation. However, premises are here placed
%% above the line "------- :: [rule_name]" and the sugar
%%
%%   i / S => i' / S'
%%
%%  is desugered to
%%
%% i' / S => S'
%% -------- ::
%% i / S => S'
%%
%% I've left the typing rules, not implemented, in comment, and some bits of the original documentation.
%% My comments are prefixed AJ:.
%%

------ :: FAILWITH
FAILWITH / d : stack => [FAILED]

------ :: failed
i / [FAILED] => [FAILED]

i1 / S => SE''
i2 / SE'' => SE'
------ :: SEQ
i1; i2 / S => SE'

------ :: NOOP
{} / S => S

i1 / S => S'
------ :: IF__tt
IF i1 i2 / True : S => S'

i2 / S => S'
------ :: IF__ff
IF i1 i2 / False : S => S'

i1; LOOP i1 / S => S'
------ :: LOOP__tt
LOOP i1 / True : S => S'

------ :: LOOP__ff
LOOP i1 / False : S => S

i1 ; LOOP_LEFT i1 / d : S => S'
------ :: LOOP_LEFT__tt
LOOP_LEFT i1 / Left d : S => S'

i1 / S => S'
------ :: DIP
DIP i1 / d : S => d : S'

i / d2 : []  =>  d3 : []
------ :: EXEC
EXEC / i : d2 : S  =>  d3 : S


%%
%% Stack operations
%%
%     DROP: Drop the top element of the stack.

% :: _ : 'A   ->   'A

----- :: DROP
DROP / d : S  =>  S

%     DUP: Duplicate the top of the stack.

% :: 'ty1 : 'A   ->   'ty1 : 'ty1 : 'A

----- :: DUP
DUP / d : S  =>  d : d : S

%     SWAP: Exchange the top two elements of the stack.

% :: 'ty1 : 'ty2 : 'A   ->   'ty2 : 'ty1 : 'A

----- :: SWAP
SWAP / d1 : d2 : S  =>  d2 : d1 : S

%     PUSH 'ty1 x: Push a constant value of a given type onto the stack.

% :: 'A   ->   'ty1 : 'A
%    iff   x :: 'ty1

----- :: PUSH
PUSH ty d / S  =>  d : S

%     UNIT: Push a unit value onto the stack.

% :: 'A   ->   unit : 'A

----- :: UNIT
UNIT / S  =>  Unit : S

%     LAMBDA 'ty1 'ty2 code: Push a lambda with given parameter and return types onto the stack.

% :: 'A ->  (lambda 'ty1 'ty2) : 'A

----- :: LAMBDA
LAMBDA ty ty' i / S  =>  i : S


%%
%% Generic comparison
%%

%     EQ: Checks that the top of the stack EQuals zero.

% :: int : 'S   ->   bool : 'S

------------------------------------- :: EQ__tt
EQ / :z_IntZero: 0 : S  =>  True : S

z <> :z_IntZero: 0
-------------------------- :: EQ__ff
EQ / z : S  =>  False : S

%     NEQ: Checks that the top of the stack does Not EQual zero.

% :: int : 'S   ->   bool : 'S

-------------------------------------- :: NEQ__ff
NEQ / :z_IntZero: 0 : S  =>  False : S

z <> :z_IntZero: 0
------------------------- :: NEQ__tt
NEQ / z : S  =>  True : S

%     LT: Checks that the top of the stack is Less Than zero.

% :: int : 'S   ->   bool : 'S

z < :z_IntZero: 0
----------------- :: LT__tt
LT / z : S  =>  True : S

z >= :z_IntZero: 0
----- :: LT__ff
LT / z : S  =>  False : S

%     GT: Checks that the top of the stack is Greater Than zero.

% :: int : 'S   ->   bool : 'S


z > :z_IntZero: 0
----------------- :: GT__tt
GT / z : S  =>  True : S

z <= :z_IntZero: 0
------------------ :: GT__ff
GT / z : S  =>  False : S

%     LE: Checks that the top of the stack is Less Than of Equal to zero.

% :: int : 'S   ->   bool : 'S

z <= :z_IntZero: 0
------------------ :: LE__tt
LE / z : S  =>  True : S

z > :z_IntZero: 0
----------------- :: LE__ff
LE / z : S  =>  False : S

%     GE: Checks that the top of the stack is Greater Than of Equal to zero.

% :: int : 'S   ->   bool : 'S


z >= :z_IntZero: 0
------------------ :: GE__tt
GE / z : S  =>  True : S

z < :z_IntZero: 0
----------------- :: GE__ff
GE / z : S  =>  False : S


% V - Operations
% Operations on booleans

%     OR

% :: bool : bool : 'S   ->   bool : 'S

----- :: OR__1
OR / True : x : S  =>  True : S

----- :: OR__2
OR / x : True : S  =>  True : S

----- :: OR__3
OR / False : False : S  =>  False : S

%     AND

% :: bool : bool : 'S   ->   bool : 'S


----- :: AND__1
AND / True : True : S  =>  True : S

----- :: AND__2
AND / False : x : S  =>  False : S

----- :: AND__3
AND / x : False : S  =>  False : S

%     XOR

% :: bool : bool : 'S   ->   bool : 'S

----- :: XOR__1
XOR / True : True : S  =>  False : S

----- :: XOR__2
XOR / False : True : S  =>  True : S

----- :: XOR__3
XOR / True : False : S  =>  True : S

----- :: XOR__4
XOR / False : False : S  =>  False : S

%     NOT

% :: bool : 'S   ->   bool : 'S

----- :: NOT__1
NOT / True : S  =>  False : S

----- :: NOT__2
NOT / False : S  =>  True : S

% Operations on integers and natural numbers

% Integers and naturals are arbitrary-precision, meaning the only size limit is fuel.

%     NEG

% :: int : 'S   ->   int : 'S
% :: nat : 'S   ->   int : 'S

----- :: NEG
NEG / n : S  =>  - n : S

%     ABS

% :: int : 'S   ->   nat : 'S

----- :: ABS
ABS / z : S  =>  abs z : S

%     ADD

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: ADD
ADD / nz1 : nz2 : S  =>  (nz1 + nz2) : S

%     SUB

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

----- :: SUB
SUB / nz1 : nz2 : S  =>  ( nz1 - nz2 ) : S

%     MUL

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: MUL
MUL / nz1 : nz2 : S  =>  ( nz1 * nz2 ) : S

%     EDIV Perform Euclidian division

% :: int : int : 'S   ->   option (pair int nat) : 'S
% :: int : nat : 'S   ->   option (pair int nat) : 'S
% :: nat : int : 'S   ->   option (pair int nat) : 'S
% :: nat : nat : 'S   ->   option (pair nat nat) : 'S

----- :: EDIV__0
EDIV / n : :n_NatZero: 0 : S  =>  None : S

nz2 <> :n_NatZero: 0
----- :: EDIV
EDIV / nz1 : nz2 : S  =>  Some ( Pair ( nz1 / nz2 ) ( nz1 % nz2 )) : S

% Bitwise logical operators are also available on unsigned integers.

%     OR

% :: nat : nat : 'S   ->   nat : 'S

----- :: OR__bit
OR / nz1 : nz2 : S  =>  ( nz1 | nz2 ) : S

%     AND (also available when the top operand is signed)

% :: nat : nat : 'S   ->   nat : 'S
% :: int : nat : 'S   ->   nat : 'S

----- :: AND__bit_nat
AND / n1 : n2 : S  =>  ( n1 & n2 ) : S

----- :: AND__bit_int_nat
AND / z1 : n2 : S  =>  ( z1 & n2 ) : S

%     XOR

% :: nat : nat : 'S   ->   nat : 'S

----- :: XOR__bit
XOR / nz1 : nz2 : S  =>  ( nz1 ^ nz2 ) : S

%     Michelson Documentation: NOT The return type of NOT is an int and not a nat. This is because the sign is also negated. The resulting integer is computed using two’s complement. For instance, the boolean negation of 0 is -1. To get a natural back, a possibility is to use AND with an unsigned mask afterwards.

% :: nat : 'S   ->   int : 'S
% :: int : 'S   ->   int : 'S

----- :: NOT__bit
NOT / n : S  =>  ~ n : S

%     LSL

% :: nat : nat : 'S   ->   nat : 'S

nz2 <= 256
----- :: LSL
LSL / nz1 : nz2 : S  =>  ( nz1 << nz2 ) : S

nz2 > 256
----- :: LSL__fail
LSL / nz1 : nz2 : S  =>  [FAILED]

%     LSR

% :: Nat : nat : 'S   ->   nat : 'S

----- :: LSR
LSR / nz1 : nz2 : S  =>  ( nz1 >> nz2 ) : S

%     COMPARE: Integer/natural comparison

% :: int : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

nz1 < nz2
----- :: COMPARE__num_lt
COMPARE / nz1 : nz2 : S  =>  - :z_IntOne: 1 : S

nz1 = nz2
----- :: COMPARE__num_eq
COMPARE / nz1 : nz2 : S  => :z_IntZero: 0 : S

nz1 > nz2
----- :: COMPARE__num_gt
COMPARE / nz1 : nz2 : S  => :z_IntOne: 1 : S

% Operations on strings

% Michelson Documentation: Strings are mostly used for naming things without having to rely on external ID databases. They are restricted to the printable subset of 7-bit ASCII, plus some escaped characters (see section on constants). So what can be done is basically use string constants as is, concatenate or splice them, and use them as keys.

%     CONCAT: String concatenation.

% :: string : string : 'S   -> string : 'S

----- :: CONCAT__string
CONCAT / s : t : S  =>  ( s ^ t ) : S

% :: string list : 'S   -> string : 'S

----- :: CONCAT__string_list_nil
CONCAT / :setlist_Nil: {} : S  =>  "" : S

CONCAT / tl : S  =>  t : S
----- :: CONCAT__string_list_cons
CONCAT / { s ; < tl > } : S  =>  ( s ^ t ) : S

% :: bytes list : 'S   -> bytes : 'S

% TODO: add semantics for the concatenation of byte sequences,
% requires adding a literal for bytes sequences

% ----- :: CONCAT_bytes_list_nil
% CONCAT / :setlist_Nil: {} : S  =>  "" : S

% CONCAT / tl : S  =>  t : S
% ----- :: CONCAT_bytes_list_cons
% CONCAT / { s ; < tl > } : S  =>  ( s ^ t ) : S


%     SIZE: number of characters in a string.

% :: string : 'S   ->   nat : 'S

----- :: SIZE__string
SIZE / s : S  =>  ( length s ) : S

%     SLICE: String access.

%         :: nat : nat : string : ‘S -> option string : ‘S




% n: length
% n': offset
n1 + n2 < length s
----- :: SLICE__some
SLICE / n1 : n2 : s : S => Some ( slice s n1 n2 ) : S

%             where ss is the substring of s at the given offset and of the given length

%                 iff offset and (offset + length) are in bounds

% n: length
% n': offset
nz1 + nz2 >= length s
----- :: SLICE
SLICE / nz1 : nz2 : s : S => None : S

%             iff offset or (offset + length) are out of bounds

%     COMPARE: Lexicographic comparison.

% :: string : string : 'S   ->   int : 'S

s < t
----- :: COMPARE__string_lt
COMPARE / s : t : S  => - :z_IntOne: 1 : S

s = t
----- :: COMPARE__string_eq
COMPARE / s : t : S  => :z_IntZero: 0 : S

s > t
----- :: COMPARE__string_gt
COMPARE / s : t : S  => :z_IntOne: 1 : S

% Operations on pairs

%     PAIR: Build a pair from the stack’s top two elements.

% :: 'ty1 : 'ty2 : 'S   ->   pair 'ty1 'ty2 : 'S

----- :: PAIR
PAIR / d : d' : S  =>  ( Pair d d' ) : S

%     CAR: Access the left part of a pair.

% :: pair 'ty1 _ : 'S   ->   'ty1 : 'S

----- :: CAR
CAR / ( Pair d d' ) : S  =>  d : S

%     CDR: Access the right part of a pair.

% :: pair _ 'ty2 : 'S   ->   'ty2 : 'S

----- :: CDR
CDR / ( Pair d d' ) : S  =>  d' : S

% Operations on sets

%     EMPTY_SET 'elt: Build a new, empty set for elements of a given type.

%     The 'elt type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S   ->   set 'elt : 'S

----- :: EMPTY_SET
EMPTY_SET cty / S  => :setlist_Nil: {} : S

%     MEM: Check for the presence of an element in a set.

% :: 'elt : set 'elt : 'S   ->  bool : 'S

----- :: MEM__set_empty
MEM / x : :setlist_Nil: {} : S  =>  False : S

COMPARE / x : y : []  => :z_IntOne: 1 : []
MEM / x : tl : S   =>  b : S
----- :: MEM__set_later
MEM / x : { y ; <tl> } : S  =>  b : S

COMPARE / x : y : []  => :z_IntZero: 0 : []
----- :: MEM__set_found
MEM / x : { y ; <tl> } : S  =>  True : S

COMPARE / x : y : []  =>  - :z_IntOne: 1 : []
----- :: MEM__set_nexists
MEM / x : { y ; <tl> } : S  =>  False : S

%     UPDATE: Inserts or removes an element in a set, replacing a previous value.

% :: 'elt : bool : set 'elt : 'S   ->   set 'elt : 'S

----- :: UPDATE__set_false
UPDATE / x : False : :setlist_Nil: {} : S  => :setlist_Nil: {} : S

----- :: UPDATE__set_add_nexists
UPDATE / x : True : :setlist_Nil: {} : S  =>  { x } : S

COMPARE / x : d : []  => :z_IntOne: 1 : []
UPDATE / x : b : tl : S  => tl' : S
----- :: UPDATE__set_cont
UPDATE / x : b : { y ; <tl> } : S  =>  { y ; <tl'> } : S

COMPARE / x : y : []  => :z_IntZero: 0 : []
----- :: UPDATE__set_remove
UPDATE / x : False : { y ; < tl > } : S  => tl : S

COMPARE / x : y : []  => :z_IntZero: 0 : []
----- :: UPDATE__set_exists
UPDATE / x : True : { y ; < tl > } : S  =>  { y ; < tl > } : S

COMPARE / x : y : []  =>  - :z_IntOne: 1 : []
----- :: UPDATE__set_remove_nexists
UPDATE / x : False : { y ; < tl > } : S  =>  { y ; < tl > } : S

COMPARE / x : y : []  =>  - :z_IntOne: 1 : []
----- :: UPDATE__set_add
%% AJ: not sure how to get around the ugliness of the conclusion here
UPDATE / x : True : { y ; < tl > } : S  =>  { x ; { y ; < tl > } } : S

%     ITER body: Apply the body expression to each element of a set. The body sequence has access to the stack.

% :: (set 'elt) : 'A   ->  'A
%    iff body :: [ 'elt : 'A -> 'A ]

----- :: ITER__set_nil
ITER body / :setlist_Nil: {} : S  =>  S

body ; ITER body / x : < tl > : S => S'
----- :: ITER__set_cons
ITER body / { x ; < tl > } : S  => S'

%     SIZE: Get the cardinality of the set.

% :: set 'elt : 'S -> nat : 'S

----- :: SIZE__set_nil
SIZE / :setlist_Nil: {} : S  => :n_NatZero: 0 : S

SIZE / tl : S  =>  n : S
----- :: SIZE__set_cons
SIZE / { d ; < tl > } : S  => :n_NatOne: 1 + n : S

% Operations on maps

%     EMPTY_MAP 'key 'val: Build a new, empty map from keys of a given type to values of another given type.

%     The 'key type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S -> map 'key 'val : 'S

----- :: EMPTY_MAP
EMPTY_MAP cty ty / S  => :map_Nil: {} : S

%     GET: Access an element in a map, returns an optional value to be checked with IF_SOME.

% :: 'key : map 'key 'val : 'S   ->   option 'val : 'S

----- :: GET__empty
GET / x : :map_Nil: {} : S  =>  None : S

COMPARE / x : k : []  => :z_IntOne: 1 : []
GET / x : m : S  =>  opt_y : S
----- :: GET__later
GET / x : { Elt k v ; < m > } : S  => opt_y : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: GET__now
GET / x : { Elt k v ; < m > } : S  =>  Some v : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: GET__nexists
GET / x : { Elt k v ; < m > } : S  =>  None : S

%     MEM: Check for the presence of a binding for a key in a map.

% :: 'key : map 'key 'val : 'S   ->  bool : 'S

----- :: MEM__map_empty
MEM / x : :map_Nil: {} : S  =>  False : S

COMPARE / x : k : []  => :z_IntOne: 1 : []
MEM / x : m : S  =>  b : S
----- :: MEM__map_later
MEM / x : { Elt k v ; < m > } : S  =>  b : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: MEM__map_now
MEM / x : { Elt k v ; < m > } : S  =>  True : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: MEM__map_nexists
MEM / x : { Elt k v ; < m > } : S  =>  False : S

%     UPDATE: Assign or remove an element in a map.

% :: 'key : option 'val : map 'key 'val : 'S   ->   map 'key 'val : 'S

----- :: UPDATE__map_false
UPDATE / x : None : :map_Nil: {} : S  => :map_Nil: {} : S

----- :: UPDATE__map_add_nexists
UPDATE / x : Some y : :map_Nil: {} : S  =>  { Elt x y } : S

COMPARE / x : k : []  => :z_IntOne: 1 : []
UPDATE / x : opt_y : m : S  =>  m' : S
----- :: UPDATE__map_cont
UPDATE / x : opt_y : { Elt k v ; < m > } : S  =>  { Elt k v ; < m' > } : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: UPDATE__map_remove
UPDATE / x : None : { Elt k v ; < m > } : S  =>  < m > : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: UPDATE__map_exists
UPDATE / x : Some y : { Elt k v ; < m > } : S  =>  { Elt k y ; < m > } : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: UPDATE__map_remove_nexists
UPDATE / x : None : { Elt k v ; < m > } : S  =>  { Elt k v ; < m > } : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: UPDATE__map_add
UPDATE / x : Some y : { Elt k v ; < m > } : S  =>  { Elt x y ; { Elt k v ; < m > }  } : S

%     MAP body: Apply the body expression to each element of a map. The body sequence has access to the stack.

% :: (map 'key 'val) : 'A   ->  (map 'key 'ty2) : 'A
%    iff   body :: [ (pair 'key 'val) : 'A -> 'ty2 : 'A ]

----- :: MAP__map_nil
MAP body / :map_Nil: {} : S  => :map_Nil: {} : S

%% AJ: I'm unsure how to read the conclusion of the original version
%% of this rule.  what is the meaning of applying body to (Pair k v) ?
%% This is how I interpret it.
body / k : v : S => v' : S
MAP body / m : S  => m'  : S
----- :: MAP__map_cons
MAP body / { Elt k v ; < m > } : S  =>  { Elt k v' ; < m' > } : S

%     ITER body: Apply the body expression to each element of a map. The body sequence has access to the stack.

% :: (map 'elt 'val) : 'A   ->  'A
%    iff   body :: [ (pair 'elt 'val) : 'A -> 'A ]

----- :: ITER__map_nil
ITER body / :map_Nil: {} : S  =>  S

body ; ITER body / (Pair k v) : m : S => S'
----- :: ITER__map_cons
ITER body / { Elt k v ; < m > } : S  => S'

%     SIZE: Get the cardinality of the map.

% :: map 'key 'val : 'S -> nat : 'S

----- :: SIZE__map_nil
SIZE / :map_Nil: {} : S  => :n_NatZero: 0 : S

SIZE / m : S  =>  n : S
----- :: SIZE__map_cons
SIZE / { Elt d d' ; < m > } : S  =>  :n_NatOne: 1 + n : S

% Operations on big_maps

% AJ: I ignore these.

% The behavior of these operations is the same as if they were normal maps, except that under the hood, the elements are loaded and deserialized on demand.

%     GET: Access an element in a big_map, returns an optional value to be checked with IF_SOME.

% :: 'key : big_map 'key 'val : 'S   ->   option 'val : 'S

%     MEM: Check for the presence of an element in a big_map.

% :: 'key : big_map 'key 'val : 'S   ->  bool : 'S

%     UPDATE: Assign or remove an element in a big_map.

% :: 'key : option 'val : big_map 'key 'val : 'S   ->   big_map 'key 'val : 'S

%%
%% Operations on optional values
%%

%     SOME: Pack a present optional value.

% :: 'ty1 : 'S   ->   option 'ty1 : 'S

----- :: SOME
SOME / v : S  =>  (Some v) : S

%     NONE 'ty1: The absent optional value.

% :: 'S   ->   option 'ty1 : 'S

----- :: NONE
NONE ty / v : S  =>  None : S

%     IF_NONE body1 body2: Inspect an optional value.

% :: option 'ty1 : 'S   ->   'ty2 : 'S
%    iff   body1 :: [ 'S -> 'ty2 : 'S]
%          body2 :: [ 'ty1 : 'S -> 'ty2 : 'S]

body1 / S => S'
----- :: IF_NONE__none
IF_NONE body1 body2 / None : S => S'

body2 / d : S => S'
----- :: IF_NONE__some
IF_NONE body1 body2 / (Some d) : S =>  S'

% Operations on unions

%     LEFT 'ty2: Pack a value in a union (left case).

% :: 'ty1 : 'S   ->   or 'ty1 'ty2 : 'S

----- :: LEFT
LEFT ty / v : S  =>  (Left v) : S

%     RIGHT 'ty1: Pack a value in a union (right case).

% :: 'ty2 : 'S   ->   or 'ty1 'ty2 : 'S

----- :: RIGHT
RIGHT ty / v : S  =>  (Right v) : S

%     IF_LEFT body1 body2: Inspect a value of a variant type.

% :: or 'ty1 'ty2 : 'S   ->   'cty : 'S
%    iff   body1 :: [ 'ty1 : 'S -> 'cty : 'S]
%          body2 :: [ 'ty2 : 'S -> 'cty : 'S]

body1 / d : S => S'
----- :: IF_LEFT__left
IF_LEFT body1 body2 / (Left d) : S  =>  S'

body2 / d : S => S'
----- :: IF_LEFT__right
IF_LEFT body1 body2 / (Right d) : S  => S'

% Operations on lists

%     CONS: Prepend an element to a list.

% :: 'ty1 : list 'ty1 : 'S   ->   list 'ty1 : 'S

----- :: CONS
CONS / d : tl : S  =>  { d ; < tl > } : S

%     NIL 'ty1: The empty list.

% :: 'S   ->   list 'ty1 : 'S

----- :: NIL
NIL ty / S  => :setlist_Nil: {} : S

%     IF_CONS body1 body2: Inspect an optional value.

% :: list 'ty1 : 'S   ->   'ty2 : 'S
%    iff   body1 :: [ 'ty1 : list 'ty1 : 'S -> 'ty2 : 'S]
%          body2 :: [ 'S -> 'ty2 : 'S]

body2 / S => S'
----- :: IF_CONS__nil
IF_CONS body1 body2 / :setlist_Nil: {} : S  =>  S'

body1 / d : tl : S => S'
----- :: IF_CONS__cons
IF_CONS body1 body2 / { d ; < tl > }  : S  => S'

%     MAP body: Apply the body expression to each element of the list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  (list 'ty2) : 'A
%    iff   body :: [ 'elt : 'A -> 'ty2 : 'A ]

body / d : S => d' : S
MAP body / tl : S  => tl' : S
----- :: MAP__list_cons
MAP body / { d ; < tl > }  : S  =>  { d' ; < tl' > } : S

----- :: MAP__list_nil
MAP body / :setlist_Nil: {} : S  => :setlist_Nil: {} : S

%     SIZE: Get the number of elements in the list.

% :: list 'elt : 'S -> nat : 'S

----- :: SIZE__list_nil
SIZE / :setlist_Nil: {} : S  => :n_NatZero: 0 : S

SIZE / tl  : S  =>  n : S
----- :: SIZE__list_cons
SIZE / { d ; <tl> } : S  =>  :n_NatOne: 1 + n : S

%     ITER body: Apply the body expression to each element of a list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  'A
%      iff body :: [ 'elt : 'A -> 'A ]

body ; ITER body / d : tl : S => S'
----- :: ITER__list_cons
ITER body / { d ; <tl> } : S  =>  S'

----- :: ITER__list_nil
ITER body / :setlist_Nil: {} : S  =>  S

embed {{coq
End syntax.
}}
