embed {{ coq
Require String.
Open Scope string_scope.
Require Import ZArith.

Module Mutez.
  Inductive mutez :=.
End Mutez.
}}

metavar nat_litteral ::= {{ coq N }}
metavar int_litteral ::= {{ coq Z }}
metavar string_litteral ::= {{ coq String.string }}
metavar timestamp_litteral ::= {{ coq Z }}
metavar signature_litteral ::= {{ coq String.string }}
metavar key_litteral ::= {{ coq String.string }}
metavar key_hash_litteral ::= {{ coq String.string }}
metavar mutez_litteral ::= {{ coq Mutez.mutez }}
metavar contract_litteral ::= {{ coq String.string }}

indexvar N ::= {{ coq nat }}

grammar

%% Operators

bop :: 'bop_' ::= {{ coq bool -> bool -> bool }} {{ phantom }}
    | || :: :: Or {{ coq orb }}
    | && :: :: And {{ coq andb }}
    | xor :: :: Xor {{ coq xorb }}

aop :: 'aop_' ::=
    | + :: :: Add
    | - :: :: Sub
    | * :: :: Mul
    | / :: :: Div
    | % :: :: Mod
    | << :: :: Lsl
    | >> :: :: Lsr

bitop :: 'bitop_' ::=
    | | :: :: Or
    | & :: :: And
    | ^ :: :: Xor

%% Data litterals

nat_lit, n :: 'n_' ::= {{ coq nat }} {{ phantom }}
  | 0 :: M :: NatZero {{ coq 0 }}
  | 1 :: M :: NatOne {{ coq 1 }}
  | 256 :: M :: NatMaxByte {{ coq 256 }}
  | length s :: M :: StringLength {{ coq (String.length s) }}
  | abs z :: M :: Abs {{ coq (Z.abs_nat [[z]]) }}

int_lit, z :: 'z_' ::= {{ coq Z }} {{ phantom }}
  | 0 :: M :: IntZero {{ coq 0 }}
  | 1 :: M :: IntOne {{ coq 1 }}

num, nz :: 'num_' ::=
  | int_lit :: :: IntConstant
  | nat_lit :: :: NatConstant
  | nz1 aop nz2 :: M :: Aop {{ coq ( num_apply_aop [[aop]] [[nz1]] [[nz2]] ) }}
  | nz1 bitop nz2 :: M :: Bitop {{ coq ( num_apply_bitop [[bitop]] [[nz1]] [[nz2]] ) }}
  | - nz :: M :: NumNeg {{ coq ( num_neg [[nz]] ) }}
  | ~ nz :: M :: BitNeg {{ coq ( num_bit_neg [[nz]] ) }}

string_lit, s , t :: 's_' ::= {{ coq String.string }} {{ phantom }}
     | "" :: M :: StringEmpty {{ coq ("") }}
     | ( s ^ s' ) :: M :: Concat {{ coq (String.append [[s]] [[s']]) }}
     | slice s n1 n2 :: M :: StringSlice {{ coq (String.substring [[n1]] [[n2]] [[s]]) }}

bool_lit, b :: 'b_' ::= {{ coq bool }} {{ phantom }}
     | True :: M :: True {{ coq true }}
     | False :: M :: False {{ coq false }}
     | ( b1 bop b2 ) :: M :: Bop {{ coq ( [[bop]] [[b1]] [[b2]] ) }}
     | ! b2  :: M :: Neg {{ coq ( negb [[b2]] ) }}

set_or_list, tl :: 'setlist_' ::= {{ coq list data }} {{ phantom }}
     | {} :: M :: Nil {{ coq nil }}
     | { d ; tl } :: M :: Cons {{ coq ([[d]] :: [[tl]])  }}
     %% meta-productions
     | { d }  :: M :: Singleton {{ coq ([[d]] :: nil)  }}
     | < tl > :: M :: Chevron {{ coq [[tl]] }}

map_elt :: '' ::=
     | Elt k v :: :: Elt

map_lit, m :: 'map_' ::= {{ coq list (data * data) }} {{ phantom }}
     | {} :: M :: Nil {{ coq nil }}
     | { Elt d d' ; m }  :: M :: Cons {{ coq (([[d]], [[d']])::[[m]]) }}
     % meta-productions
     | { Elt d d' }  :: M :: Singleton {{ coq (([[d]], [[d']])::nil) }}
     | < m > :: M :: Chevron {{ coq [[m]] }}
     %| { Elt d1 d1'  ; .. ; Elt dN dN' } :: :: Map


%% Data

data, x, y, k, v, d, opt_y :: d_ ::=
  | num :: :: Num
  | string_lit :: :: StringConstant
  | bool_lit :: :: Bool
  | timestamp_litteral :: :: Timestamp
  | signature_litteral :: :: Signature
  | key_litteral :: :: Key
  | key_hash_litteral :: :: Key_hash
  | mutez_litteral :: :: Mutez
  | contract_litteral :: :: Contract
  | Unit :: :: Unit
  | Pair x y :: :: Pair
  | Left x :: :: Left
  | Right y :: :: Right
  | Some x :: :: Some
  | None :: :: None
  | set_or_list :: :: SetList
  | map_lit :: :: Map
  | code :: :: instruction
  | 0 :: M :: zero {{ coq data_int 0%Z}}

  | ( data ) :: M :: Paren {{ coq ( [[data]] ) }}

%% Types

comparable_type, kty, cty :: cty_ ::=
  | string    :: :: string
  | nat       :: :: nat
  | int       :: :: int
  | bytes     :: :: bytes
  | bool      :: :: bool
  | mutez     :: :: mutez
  | key_hash  :: :: key_hash
  | timestamp :: :: timestamp

type, ty, vty :: ty_ ::=
  | cty             :: :: Comparable_type
  | key             :: :: key
  | unit            :: :: unit
  | signature       :: :: signature
  | option type     :: :: option
  | list type       :: :: list
  | set cty           :: :: set
  | contract type   :: :: contract
  | address         :: :: address
  | operation       :: :: operation
  | pair ty1 ty2        :: :: pair
  | or ty1 ty2          :: :: or
  | lambda ty1 ty2      :: :: lambda
  | map kty vty     :: :: map
  | big_map kty vty :: :: big_map
  | self_ty         :: M :: self_ty {{coq self_ty}}
  | ( ty1 )           :: M :: parens {{coq ([[ty1]])}}

%% Operations

comparison :: '' ::=
  | EQ :: :: EQ
  | NEQ :: :: NEQ
  | LT :: :: LT
  | GT :: :: GT
  | LE :: :: LE
  | GE :: :: GE

binary_bitwise :: '' ::=
  | OR :: :: OR
  | AND :: :: AND
  | XOR :: :: XOR

hash_function :: '' ::=
  | HASH_KEY :: :: HASH_KEY
  | BLAKE2B :: :: BLAKE2B
  | SHA256 :: :: SHA256
  | SHA512 :: :: SHA512

%% Instructions

nullary :: 'i_' ::=
  | PUSH ty1 x :: :: PUSH
  | UNIT :: :: UNIT
  | LAMBDA ty1 ty2 code :: :: LAMBDA
  | EMPTY_SET cty :: :: EMPTY_SET
  | EMPTY_MAP kty vty :: :: EMPTY_MAP
  | NONE ty1 :: :: NONE
  | NIL ty1 :: :: NIL
  | BALANCE :: :: BALANCE
  | SOURCE :: :: SOURCE
  | SENDER :: :: SENDER
  | SELF :: :: SELF
  | AMOUNT :: :: AMOUNT
  | STEPS_TO_QUOTA :: :: STEPS_TO_QUOTA
  | NOW :: :: NOW

unary :: 'i_' ::=
  | comparison :: :: unary_comparison
  | hash_function :: :: unary_hash
  | NOT :: :: NOT
  | NEG :: :: NEG
  | ABS :: :: ABS
  | SIZE :: :: SIZE
  | CAR :: :: CAR
  | CDR :: :: CDR
  | SOME :: :: SOME
  | LEFT ty2 :: :: LEFT
  | RIGHT ty1 :: :: RIGHT
  | ADDRESS :: :: ADDRESS
  | CONTRACT ty :: :: CONTRACT
  | SET_DELEGATE :: :: SET_DELEGATE
  | IMPLICIT_ACCOUNT :: :: IMPLICIT_ACCOUNT
  | PACK :: :: PACK
  | UNPACK ty1 :: :: UNPACK

binary :: 'i_' ::=
  | binary_bitwise :: :: b_bitwise
  | EXEC :: :: EXEC
  | LSL :: :: LSL
  | LSR :: :: LSR
  | COMPARE :: :: COMPARE
  | CONCAT :: :: CONCAT
  | PAIR :: :: PAIR
  | MEM :: :: MEM
  | GET :: :: GET
  | CONS :: :: CONS

non_failing_function :: 'i_' ::=
  | nullary :: :: nff_nullary
  | unary :: :: nff_unary
  | binary :: :: nff_binary

  | DROP :: :: DROP
  | DUP :: :: DUP
  | SWAP :: :: SWAP

  | SLICE :: :: SLICE
  | UPDATE :: :: UPDATE
  | CREATE_CONTRACT :: :: CREATE_CONTRACT
  | CREATE_CONTRACT code :: :: CREATE_CONSTRACT_litteral
  | CREATE_ACCOUNT :: :: CREATE_ACCOUNT
  | TRANSFER_TOKENS :: :: TRANSFER_TOKENS
  | CHECK_SIGNATURE :: :: CHECK_SIGNATURE

function :: 'i_' ::=
  | non_failing_function :: :: Non_failing
  | ADD :: :: ADD
  | SUB :: :: SUB
  | MUL :: :: MUL
  | EDIV :: :: EDIV

%% Code

code, i, body :: 'i_' ::=
  | function :: :: Fun
  | FAILWITH :: :: FAILWITH
  | {} :: :: NOOP
  | code1 ; code2 :: :: SEQ
  | IF code1 code2 :: :: IF_
  | LOOP code :: :: LOOP
  | LOOP_LEFT code :: :: LOOP_LEFT
  | DIP code :: :: DIP
  | ITER code :: :: ITER
  | MAP code :: :: MAP
  | IF_NONE code1 code2 :: :: IF_NONE
  | IF_LEFT code1 code2 :: :: IF_LEFT
  | IF_RIGHT code1 code2 :: :: IF_RIGHT
  | IF_CONS code1 code2 :: :: IF_CONS

%% Stack

stack, st, S :: Stack_ ::= {{coq list data }} {{ phantom }}
  | [] :: M :: empty {{ coq nil }}
  | d : S :: M :: cons {{ coq ([[d]] :: [[S]]) }}

stack_type, A, B, C :: Stack_type_ ::= {{ coq Datatypes.list type }} {{ phantom }}
  | [] :: :: empty {{ coq nil}}
  | ty1 ':' A :: :: cons {{ coq (cons[[ty1]][[A]])}}
  | A @ B :: M :: append {{ coq (List.app[[A]][[B]])}}

% A stackerr is either failed or ty1 stack, which is ty1 list of data.
stackerr, SE :: 'SE_' ::=
       | [FAILED] :: :: Failed
       | stack :: :: Stack

%% Formulas

formula :: formula_ ::=
  | judgement :: :: judgement
  | formula1 .. formulaN :: :: dots
  | get_contract_type contract_litteral ty :: M :: get_contract_rel
    {{ coq get_contract_rel [[contract_litteral]] [[ty]] }}
  | x = y :: M :: eq {{coq (compare [[x]] EQ [[y]])}}
  | x <> y :: M :: neq {{coq (compare [[x]] NEQ [[y]])}}
  | x < y :: M :: lt {{coq (compare [[x]] LT [[y]])}}
  | x > y :: M :: gt {{coq (compare [[x]] GT [[y]])}}
  | x <= y :: M :: le {{coq (compare [[x]] LE [[y]])}}
  | x >= y :: M :: ge {{coq (compare [[x]] GE [[y]])}}

embed {{coq
Section syntax.
  Variable self_ty : type.
  Variable get_contract_rel : String.string -> type -> Prop.
}}

embed {{ coq
Load Formulas.
}}


defns
Typing :: 't_' ::=

  defn
  x '::' ty :: :: data_has_type :: 'data_' by

       ------------------ :: int
       int_lit :: int

       ------------------ :: nat
       nat_lit :: nat

       ------------------------ :: string
       string_lit :: string

       ------------------------------ :: timestamp
       timestamp_litteral :: timestamp

       ------------------------------ :: signature
       signature_litteral :: signature

       ------------------ :: key
       key_litteral :: key

       ---------------------------- :: key_hash
       key_hash_litteral :: key_hash

       ---------------------- :: mutez
       mutez_litteral :: mutez

       get_contract_type contract_litteral ty1
       ------------------------------------- :: contract
       contract_litteral :: contract ty1

       ----------- :: Unit
       Unit :: unit

       ----------- :: bool
       bool_lit :: bool

       x :: ty1
       y :: ty2
       ------------------- :: Pair
       Pair x y :: pair ty1 ty2

       x :: ty1
       --------------- :: Left
       Left x :: or ty1 ty2

       y :: ty2
       ---------------- :: Right
       Right y :: or ty1 ty2

       x :: ty1
       ----------------- :: Some
       Some x :: option ty1

       --------------- :: None
       None :: option ty1

       ------------------------ :: set_empty
       :setlist_Nil: {} :: set cty

       x :: cty
       tl :: set cty
       ------------------------ :: set_cons
       { x ; <tl> } :: set cty

       ------------------------ :: list_empty
       :setlist_Nil: {} :: list cty

       x :: cty
       tl :: list cty
       ------------------------ :: list_cons
       { x ; <tl> } :: list cty

       ------------------------ :: map_empty
       :map_Nil: {} :: map kty vty

       x :: kty
       y :: vty
       m :: map kty vty
       ------------------------ :: map_cons
       { Elt x y ; <m> } :: map kty vty

       code :: ty1 : [] => ty2 : []
       ------------------------- :: instruction
       code :: lambda ty1 ty2

  defn
  map_elt '::' kty, vty :: :: map_elt_has_type :: 'map_elt_' by

       k :: kty
       v :: vty
       ------------------ :: map_elt
       Elt k v :: kty, vty

  defn
  nullary '::' -> ty1 :: :: null_has_type :: 'fun0_' by

       x :: ty1
       --------------- :: PUSH
       PUSH ty1 x :: -> ty1

       -------------- :: UNIT
       UNIT :: -> unit

       code :: ty1 : [] => ty2 : []
       ------------------------------- :: LAMBDA
       LAMBDA ty1 ty2 code :: -> lambda ty1 ty2

       ---------------------- :: EMPTY_SET
       EMPTY_SET cty :: -> set cty

       ---------------------------------- :: EMPTY_MAP
       EMPTY_MAP kty vty :: -> map kty vty

       -------------------- :: NONE
       NONE ty1 :: -> option ty1

       ----------------- :: NIL
       NIL ty1 :: -> list ty1

       ------------------ :: BALANCE
       BALANCE :: -> mutez

       ------------------- :: SOURCE
       SOURCE :: -> address

       ------------------- :: SENDER
       SENDER :: -> address

       ----------------- :: SELF
       SELF :: -> self_ty

       ----------------- :: AMOUNT
       AMOUNT :: -> mutez

       ----------------------- :: STEPS_TO_QUOTA
       STEPS_TO_QUOTA :: -> nat

       ------------------ :: NOW
       NOW :: -> timestamp

  defn
  unary '::' ty1 -> ty2 :: :: unary_has_type :: 'fun1_' by

       ------------------------ :: comparison
       comparison :: int -> bool

       ------------------ :: NOT_bool
       NOT :: bool -> bool

       ---------------- :: NOT_nat
       NOT :: nat -> int

       ---------------- :: NOT_int
       NOT :: int -> int

       ---------------- :: NEG_nat
       NEG :: nat -> int

       ---------------- :: NEG_int
       NEG :: int -> int

       ---------------- :: ABS
       ABS :: int -> nat

       ------------------- :: SIZE_set
       SIZE :: set cty -> nat

       ------------------------- :: SIZE_map
       SIZE :: map kty vty -> nat

       -------------------- :: SIZE_list
       SIZE :: list ty1 -> nat

       -------------------- :: SIZE_string
       SIZE :: string -> nat

       ------------------- :: SIZE_bytes
       SIZE :: bytes -> nat

       ------------------- :: CAR
       CAR :: pair ty1 ty2 -> ty1

       ------------------- :: CDR
       CDR :: pair ty1 ty2 -> ty2

       -------------------- :: SOME
       SOME :: ty1 -> option ty1

       -------------------- :: LEFT
       LEFT ty2 :: ty1 -> or ty1 ty2

       --------------------- :: RIGHT
       RIGHT ty1 :: ty2 -> or ty1 ty2

       ------------------------------- :: ADDRESS
       ADDRESS :: contract ty1 -> address

       ---------------------------------- :: CONTRACT
       CONTRACT ty1 :: address -> contract ty1

       ------------------------------------------- :: SET_DELEGATE
       SET_DELEGATE :: option key_hash -> operation

       -------------------------------------------- :: IMPLICIT_ACCOUNT
       IMPLICIT_ACCOUNT :: key_hash -> contract unit

       ----------------- :: PACK
       PACK :: ty1 -> bytes

       --------------------- :: UNPACK
       UNPACK ty1 :: bytes -> ty1

       -------------------------- :: HASH_KEY
       HASH_KEY :: key -> key_hash

       ------------------------------ :: HASH
       hash_function :: bytes -> bytes

  defn
  binary '::' ty1 -> ty2 -> ty3 :: :: bin_has_type :: 'fun2_' by

       ------------------------------------- :: bitwise_bool
       binary_bitwise :: bool -> bool -> bool

       ---------------------------------- :: bitwise_nat
       binary_bitwise :: nat -> nat -> nat

       --------------------------- :: EXEC
       EXEC :: ty1 -> lambda ty1 ty2 -> ty2

       ----------------------- :: LSL
       LSL :: nat -> nat -> nat

       ----------------------- :: LSR
       LSR :: nat -> nat -> nat

       ----------------------- :: COMPARE
       COMPARE :: cty -> cty -> int

       ----------------------------------- :: CONCAT_string
       CONCAT :: string -> string -> string

       -------------------------------- :: CONCAT_bytes
       CONCAT :: bytes -> bytes -> bytes

       ------------------------- :: PAIR
       PAIR :: ty1 -> ty2 -> pair ty1 ty2

       ------------------------ :: MEM_set
       MEM :: cty -> set cty -> bool

       -------------------------------- :: MEM_map
       MEM :: kty -> map kty vty -> bool

       ------------------------------------ :: MEM_big_map
       MEM :: kty -> big_map kty vty -> bool

       -------------------------------------- :: GET_map
       GET :: kty -> map kty vty -> option vty

       ------------------------------------------ :: GET_big_map
       GET :: kty -> big_map kty vty -> option vty

       ---------------------------- :: CONS
       CONS :: ty1 -> list ty1 -> list ty1

  defn
  function '::' A -> B :: :: fun_has_type :: 'fun_' by

       nullary :: ty1
       ----------------------- :: nullary
       nullary :: [] -> ty1 : []

       unary :: ty1 -> ty2
       -------------------------- :: unary
       unary :: ty1 : [] -> ty2 : []

       binary :: ty1 -> ty2 -> ty3
       ---------------------------------- :: binary
       binary :: ty1 : ty2 : [] -> ty3 : []

       -------------------- :: DROP
       DROP :: ty1 : [] -> []

       ----------------------------- :: DUP
       DUP :: ty1 : [] -> ty1 : ty1 : []

       ----------------------------------- :: SWAP
       SWAP :: ty1 : ty2 : [] -> ty2 : ty1 : []

       --------------------------------------------------------- :: SLICE_string
       SLICE :: nat : nat : string : [] -> option string : []

       ------------------------------------------------------- :: SLICE_bytes
       SLICE :: nat : nat : bytes : [] -> option bytes : []

       ------------------------------------------------ :: UPDATE_set
       UPDATE :: cty : bool : set cty : [] -> set cty : []

       ------------------------------------------------------------- :: UPDATE_map
       UPDATE :: kty : vty : map kty vty : [] -> map kty vty : []

       --------------------------------------------------------------------- :: UPDATE_big_map
       UPDATE :: kty : vty : big_map kty vty : [] -> big_map kty vty : []


       -------------------------------------------------------------------------------------------------------------------------------------------------------------- :: CREATE_CONTRACT
       CREATE_CONTRACT :: key_hash : option key_hash : bool : bool : mutez : lambda (pair ty1 ty2) (pair (list operation) ty2) : ty2 : [] -> operation : address : []

       code :: pair ty1 ty2 : [] => pair (list operation) ty2 : []
       -------------------------------------------------------------------------------------------------------------------- :: CREATE_CONTRACT_l
       CREATE_CONTRACT code :: key_hash : option key_hash : bool : bool : mutez : ty2 : [] -> operation : address : []


       ------------------------------------------------------------------------------------------------------- :: CREATE_ACCOUNT
       CREATE_ACCOUNT :: key_hash : option key_hash : bool : mutez : [] -> operation : contract unit : []


       ------------------------------------------------------------------- :: TRANSFER_TOKENS
       TRANSFER_TOKENS :: ty1 : mutez : contract ty1 : [] -> operation : []


       --------------------------------------------------------------- :: CHECK_SIGNATURE
       CHECK_SIGNATURE :: key : signature : bytes : [] -> bool : []


       ----------------------------------- :: ADD_nat_nat
       ADD :: nat : nat : [] -> nat : []

       ----------------------------------- :: ADD_nat_int
       ADD :: nat : int : [] -> int : []

       ----------------------------------- :: ADD_int_nat
       ADD :: int : nat : [] -> int : []

       ----------------------------------- :: ADD_int_int
       ADD :: int : int : [] -> int : []

       ----------------------------------------------- :: ADD_timestamp_int
       ADD :: timestamp : int : [] -> timestamp : []

       ----------------------------------------------- :: ADD_int_timestamp
       ADD :: int : timestamp : [] -> timestamp : []

       ----------------------------------------- :: ADD_mutez_mutez_mutez
       ADD :: mutez : mutez : [] -> mutez : []

       ----------------------------------- :: SUB_nat_nat
       SUB :: nat : nat : [] -> int : []

       ----------------------------------- :: SUB_nat_int
       SUB :: nat : int : [] -> int : []

       ----------------------------------- :: SUB_int_nat
       SUB :: int : nat : [] -> int : []

       ----------------------------------- :: SUB_int_int
       SUB :: int : int : [] -> int : []

       ----------------------------------------------- :: SUB_timestamp_int
       SUB :: timestamp : int : [] -> timestamp : []

       ----------------------------------------------- :: SUB_timestamp_timestamp
       SUB :: timestamp : timestamp : [] -> int : []

       ----------------------------------------- :: SUB_mutez_mutez
       SUB :: mutez : mutez : [] -> mutez : []

       ----------------------------------- :: MUL_nat_nat
       MUL :: nat : nat : [] -> nat : []

       ----------------------------------- :: MUL_nat_int
       MUL :: nat : int : [] -> int : []

       ----------------------------------- :: MUL_int_nat
       MUL :: int : nat : [] -> int : []

       ----------------------------------- :: MUL_int_int
       MUL :: int : int : [] -> int : []

       --------------------------------------- :: MUL_mutez_nat
       MUL :: mutez : nat : [] -> mutez : []

       --------------------------------------- :: MUL_nat_mutez
       MUL :: nat : mutez : [] -> mutez : []

       ------------------------------------------- :: EDIV_nat_nat
       EDIV :: nat : nat : [] -> nat : nat : []

       ------------------------------------------- :: EDIV_nat_int
       EDIV :: nat : int : [] -> int : nat : []

       ------------------------------------------- :: EDIV_int_nat
       EDIV :: int : nat : [] -> int : nat : []

       ------------------------------------------- :: EDIV_int_int
       EDIV :: int : int : [] -> int : nat : []

       ------------------------------------------------- :: EDIV_mutez_nat
       EDIV :: mutez : nat : [] -> mutez : mutez : []

       ------------------------------------------------- :: EDIV_mutez_mutez
       EDIV :: mutez : mutez : [] -> nat : mutez : []

  defn
  code '::' A => B :: :: code_has_type :: 'code_' by

       function :: A -> B
       ------------------------- :: function
       function :: A @ C => B @ C

       ---------------------- :: FAILWITH
       FAILWITH :: ty1 : A => B

       ------------- :: NOOP
       {} :: A => A

       code1 :: A => B
       code2 :: B => C
       ------------------------ :: SEQ
       code1; code2 :: A => C

       code1 :: A => B
       code2 :: A => B
       ------------------------------- :: IF
       IF code1 code2 :: bool : A => B

       code :: A => bool : A
       -------------------------- :: LOOP
       LOOP code :: bool : A => A

       code :: ty1 : A => or ty1 ty2 : A
       --------------------------------- :: LOOP_LEFT
       LOOP_LEFT code :: or ty1 ty2 : A => A

       code :: A => B
       --------------------------- :: DIP
       DIP code :: ty1 : A => ty1 : B

       code :: ty1 : A => A
       ---------------------------- :: ITER_list
       ITER code :: list ty1 : A => A

       code :: cty : A => A
       ---------------------------- :: ITER_set
       ITER code :: set cty : A => A

       code :: (pair kty vty) : A => A
       --------------------------------- :: ITER_map
       ITER code :: map kty vty : A => A

       code :: ty1 : A => ty2 : A
       ------------------------------------- :: MAP_list
       MAP code :: list ty1 : A => list ty2 : A

       code :: (pair kty ty1) : A => ty2 : A
       ------------------------------------------- :: MAP_map
       MAP code :: map kty ty1 : A => map kty ty2 : A

       code1 :: A => B
       code2 :: ty1 : A => B
       ---------------------------------------- :: IF_NONE
       IF_NONE code1 code2 :: option ty1 : A => B

       code1 :: ty1 : A => B
       code2 :: ty2 : A => B
       -------------------------------------- :: IF_LEFT
       IF_LEFT code1 code2 :: or ty1 ty2 : A => B

       code1 :: ty2 : A => B
       code2 :: ty1 : A => B
       -------------------------------------- :: IF_RIGHT
       IF_RIGHT code1 code2 :: or ty1 ty2 : A => B

       code1 :: ty1 : list ty1 : A => B
       code2 :: A => B
       -------------------------------------- :: IF_CONS
       IF_CONS code1 code2 :: list ty1 : A => B

defns
BigStep :: '' ::=


%% A big-step goes from an instruction (which is possible ty1 sequence
%% of instructions), an initial stack to ty1 final stack.

% Local big-step rules
defn
i / stackerr => stackerr'  :: :: BigStep :: 'bs_'
{{ tex [[i]] / [[stackerr]] \Rightarrow [[stackerr']] }}
by


%%
%% Now follows the rules. As far as possible, I follow the look of the
%% rules in the Michelson documentation. However, premises are here placed
%% above the line "------- :: [rule_name]" and the sugar
%%
%%   i / S => i' / S'
%%
%%  is desugered to
%%
%% i' / S => S'
%% -------- ::
%% i / S => S'
%%
%% I've left the typing rules, not implemented, in comment, and some bits of the original documentation.
%% My comments are prefixed AJ:.
%%

------ :: failwith
FAILWITH / d : stack => [FAILED]

------ :: failed
i / [FAILED] => [FAILED]

i1 / S => SE''
i2 / SE'' => SE'
------ :: sequence
i1; i2 / S => SE'

------ :: NOOP
{} / S => S

i1 / S => S'
------ :: if_tt
IF i1 i2 / True : S => S'

i2 / S => S'
------ :: if_ff
IF i1 i2 / False : S => S'

i1; LOOP i1 / S => S'
------ :: loop_tt
LOOP i1 / True : S => S'

------ :: loop_ff
LOOP i1 / False : S => S

i1 ; LOOP_LEFT i1 / d : S => S'
------ :: loop_left_tt
LOOP_LEFT i1 / Left d : S => S'

i1 / S => S'
------ :: dip
DIP i1 / d : S => d : S'

i / d2 : []  =>  d3 : []
------ :: exec
EXEC / i : d2 : S  =>  d3 : S


%%
%% Stack operations
%%
%     DROP: Drop the top element of the stack.

% :: _ : 'A   ->   'A

----- :: drop
DROP / d : S  =>  S

%     DUP: Duplicate the top of the stack.

% :: 'ty1 : 'A   ->   'ty1 : 'ty1 : 'A

----- :: dup
DUP / d : S  =>  d : d : S

%     SWAP: Exchange the top two elements of the stack.

% :: 'ty1 : 'ty2 : 'A   ->   'ty2 : 'ty1 : 'A

----- :: swap
SWAP / d1 : d2 : S  =>  d2 : d1 : S

%     PUSH 'ty1 x: Push ty1 constant value of ty1 given type onto the stack.

% :: 'A   ->   'ty1 : 'A
%    iff   x :: 'ty1

----- :: push
PUSH ty d / S  =>  d : S

%     UNIT: Push ty1 unit value onto the stack.

% :: 'A   ->   unit : 'A

----- :: unit
UNIT / S  =>  Unit : S

%     LAMBDA 'ty1 'ty2 code: Push ty1 lambda with given parameter and return types onto the stack.

% :: 'A ->  (lambda 'ty1 'ty2) : 'A

----- :: lambda
LAMBDA ty ty' i / S  =>  i : S


%%
%% Generic comparison
%%

%     EQ: Checks that the top of the stack EQuals zero.

% :: int : 'S   ->   bool : 'S

------------------------------------- :: eq_tt
EQ / :z_IntZero: 0 : S  =>  True : S

z <> :z_IntZero: 0
-------------------------- :: eq_ff
EQ / z : S  =>  False : S

%     NEQ: Checks that the top of the stack does Not EQual zero.

% :: int : 'S   ->   bool : 'S

-------------------------------------- :: neq_ff
NEQ / :z_IntZero: 0 : S  =>  False : S

z <> :z_IntZero: 0
------------------------- :: neq_tt
NEQ / z : S  =>  True : S

%     LT: Checks that the top of the stack is Less Than zero.

% :: int : 'S   ->   bool : 'S

z < :z_IntZero: 0
----------------- :: lt_tt
LT / z : S  =>  True : S

z >= :z_IntZero: 0
----- :: lt_ff
LT / z : S  =>  False : S

%     GT: Checks that the top of the stack is Greater Than zero.

% :: int : 'S   ->   bool : 'S


z > :z_IntZero: 0
----------------- :: gt_tt
GT / z : S  =>  True : S

z <= :z_IntZero: 0
------------------ :: gt_ff
GT / z : S  =>  False : S

%     LE: Checks that the top of the stack is Less Than of Equal to zero.

% :: int : 'S   ->   bool : 'S

z <= :z_IntZero: 0
------------------ :: le_tt
LE / z : S  =>  True : S

z > :z_IntZero: 0
----------------- :: le_ff
LE / z : S  =>  False : S

%     GE: Checks that the top of the stack is Greater Than of Equal to zero.

% :: int : 'S   ->   bool : 'S


z >= :z_IntZero: 0
------------------ :: ge
GE / z : S  =>  True : S

z < :z_IntZero: 0
----------------- :: lt
GE / z : S  =>  False : S


% V - Operations
% Operations on booleans

%     OR

% :: bool : bool : 'S   ->   bool : 'S

----- :: or1
OR / True : x : S  =>  True : S

----- :: or2
OR / x : True : S  =>  True : S

----- :: or3
OR / False : False : S  =>  False : S

%     AND

% :: bool : bool : 'S   ->   bool : 'S


----- :: and1
AND / True : True : S  =>  True : S

----- :: and2
AND / False : x : S  =>  False : S

----- :: and3
AND / x : False : S  =>  False : S

%     XOR

% :: bool : bool : 'S   ->   bool : 'S

----- :: xor1
XOR / True : True : S  =>  False : S

----- :: xor2
XOR / False : True : S  =>  True : S

----- :: xor3
XOR / True : False : S  =>  True : S

----- :: xor4
XOR / False : False : S  =>  False : S

%     NOT

% :: bool : 'S   ->   bool : 'S

----- :: not1
NOT / True : S  =>  False : S

----- :: not2
NOT / False : S  =>  True : S

% Operations on integers and natural numbers

% Integers and naturals are arbitrary-precision, meaning the only size limit is fuel.

%     NEG

% :: int : 'S   ->   int : 'S
% :: nat : 'S   ->   int : 'S

----- :: neg
NEG / n : S  =>  - n : S

%     ABS

% :: int : 'S   ->   nat : 'S

----- :: abs
ABS / z : S  =>  abs z : S

%     ADD

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: add
ADD / nz1 : nz2 : S  =>  (nz1 + nz2) : S

%     SUB

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

----- :: sub
SUB / nz1 : nz2 : S  =>  ( nz1 - nz2 ) : S

%     MUL

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: mul
MUL / nz1 : nz2 : S  =>  ( nz1 * nz2 ) : S

%     EDIV Perform Euclidian division

% :: int : int : 'S   ->   option (pair int nat) : 'S
% :: int : nat : 'S   ->   option (pair int nat) : 'S
% :: nat : int : 'S   ->   option (pair int nat) : 'S
% :: nat : nat : 'S   ->   option (pair nat nat) : 'S

----- :: ediv_0
EDIV / n : :n_NatZero: 0 : S  =>  None : S

nz2 <> :n_NatZero: 0
----- :: ediv
EDIV / nz1 : nz2 : S  =>  Some ( Pair ( nz1 / nz2 ) ( nz1 % nz2 )) : S

% Bitwise logical operators are also available on unsigned integers.

%     OR

% :: nat : nat : 'S   ->   nat : 'S

----- :: bit_or
OR / nz1 : nz2 : S  =>  ( nz1 | nz2 ) : S

%     AND (also available when the top operand is signed)

% :: nat : nat : 'S   ->   nat : 'S
% :: int : nat : 'S   ->   nat : 'S

----- :: bit_and
AND / nz1 : nz2 : S  =>  ( nz1 & nz2 ) : S

%     XOR

% :: nat : nat : 'S   ->   nat : 'S

----- :: bit_xor
XOR / nz1 : nz2 : S  =>  ( nz1 ^ nz2 ) : S

%     Michelson Documentation: NOT The return type of NOT is an int and not ty1 nat. This is because the sign is also negated. The resulting integer is computed using two’s complement. For instance, the boolean negation of 0 is -1. To get ty1 natural back, ty1 possibility is to use AND with an unsigned mask afterwards.

% :: nat : 'S   ->   int : 'S
% :: int : 'S   ->   int : 'S

----- :: bit_not
NOT / n : S  =>  ~ n : S

%     LSL

% :: nat : nat : 'S   ->   nat : 'S

nz2 <= 256
----- :: lsl
LSL / nz1 : nz2 : S  =>  ( nz1 << nz2 ) : S

nz2 > 256
----- :: lsl_fail
LSL / nz1 : nz2 : S  =>  [FAILED]

%     LSR

% :: Nat : nat : 'S   ->   nat : 'S

----- :: lsr
LSR / nz1 : nz2 : S  =>  ( nz1 >> nz2 ) : S

%     COMPARE: Integer/natural comparison

% :: int : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

nz1 < nz2
----- :: compare_num_lt
COMPARE / nz1 : nz2 : S  =>  - :z_IntOne: 1 : S

nz1 = nz2
----- :: compare_num_eq
COMPARE / nz1 : nz2 : S  => :z_IntZero: 0 : S

nz1 > nz2
----- :: compare_num_gt
COMPARE / nz1 : nz2 : S  => :z_IntOne: 1 : S

% Operations on strings

% Michelson Documentation: Strings are mostly used for naming things without having to rely on external ID databases. They are restricted to the printable subset of 7-bit ASCII, plus some escaped characters (see section on constants). So what can be done is basically use string constants as is, concatenate or splice them, and use them as keys.

%     CONCAT: String concatenation.

% :: string : string : 'S   -> string : 'S

----- :: concat_string
CONCAT / s : t : S  =>  ( s ^ t ) : S

% :: string list : 'S   -> string : 'S

----- :: concat_list_nil
CONCAT / :setlist_Nil: {} : S  =>  "" : S

CONCAT / tl : S  =>  t : S
----- :: concat_list_cons
CONCAT / { s ; < tl > } : S  =>  ( s ^ t ) : S

%     SIZE: number of characters in ty1 string.

% :: string : 'S   ->   nat : 'S

----- :: size_string
SIZE / s : S  =>  ( length s ) : S

%     SLICE: String access.

%         :: nat : nat : string : ‘S -> option string : ‘S




% n: length
% n': offset
n1 + n2 < length s
----- :: slice_some
SLICE / n1 : n2 : s : S => Some ( slice s n1 n2 ) : S

%             where ss is the substring of s at the given offset and of the given length

%                 iff offset and (offset + length) are in bounds

% n: length
% n': offset
nz1 + nz2 >= length s
----- :: slice
SLICE / nz1 : nz2 : s : S => None : S

%             iff offset or (offset + length) are out of bounds

%     COMPARE: Lexicographic comparison.

% :: string : string : 'S   ->   int : 'S

s < t
----- :: compare_string_lt
COMPARE / s : t : S  => - :z_IntOne: 1 : S

s = t
----- :: compare_string_eq
COMPARE / s : t : S  => :z_IntZero: 0 : S

s > t
----- :: compare_string_gt
COMPARE / s : t : S  => :z_IntOne: 1 : S

% Operations on pairs

%     PAIR: Build ty1 pair from the stack’s top two elements.

% :: 'ty1 : 'ty2 : 'S   ->   pair 'ty1 'ty2 : 'S

----- :: pair
PAIR / d : d' : S  =>  ( Pair d d' ) : S

%     CAR: Access the left part of ty1 pair.

% :: pair 'ty1 _ : 'S   ->   'ty1 : 'S

----- :: car
CAR / ( Pair d d' ) : S  =>  d : S

%     CDR: Access the right part of ty1 pair.

% :: pair _ 'ty2 : 'S   ->   'ty2 : 'S

----- :: cdr
CDR / ( Pair d d' ) : S  =>  d' : S

% Operations on sets

%     EMPTY_SET 'elt: Build ty1 new, empty set for elements of ty1 given type.

%     The 'elt type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S   ->   set 'elt : 'S

----- :: set_empty
EMPTY_SET cty / S  => :setlist_Nil: {} : S

%     MEM: Check for the presence of an element in ty1 set.

% :: 'elt : set 'elt : 'S   ->  bool : 'S

----- :: set_mem_empty
MEM / x : :setlist_Nil: {} : S  =>  False : S

COMPARE / x : y : []  => :z_IntOne: 1 : []
MEM / x : tl : S   =>  b : S
----- :: set_mem_later
MEM / x : { y ; <tl> } : S  =>  b : S

COMPARE / x : y : []  => :z_IntZero: 0 : []
----- :: set_mem_found
MEM / x : { y ; <tl> } : S  =>  True : S

COMPARE / x : y : []  =>  - :z_IntOne: 1 : []
----- :: set_mem_nexists
MEM / x : { y ; <tl> } : S  =>  False : S

%     UPDATE: Inserts or removes an element in ty1 set, replacing ty1 previous value.

% :: 'elt : bool : set 'elt : 'S   ->   set 'elt : 'S

----- :: set_update_false
UPDATE / x : False : :setlist_Nil: {} : S  => :setlist_Nil: {} : S

----- :: set_update_add_nexists
UPDATE / x : True : :setlist_Nil: {} : S  =>  { x } : S

COMPARE / x : d : []  => :z_IntOne: 1 : []
UPDATE / x : b : tl : S  => tl' : S
----- :: set_update_cont
UPDATE / x : b : { y ; <tl> } : S  =>  { y ; <tl'> } : S

COMPARE / x : y : []  => :z_IntZero: 0 : []
----- :: set_update_remove
UPDATE / x : False : { y ; < tl > } : S  => tl : S

COMPARE / x : y : []  => :z_IntZero: 0 : []
----- :: set_update_exists
UPDATE / x : True : { y ; < tl > } : S  =>  { y ; < tl > } : S

COMPARE / x : y : []  =>  - :z_IntOne: 1 : []
----- :: set_update_remove_nexists
UPDATE / x : False : { y ; < tl > } : S  =>  { y ; < tl > } : S

COMPARE / x : y : []  =>  - :z_IntOne: 1 : []
----- :: set_update_add
%% AJ: not sure how to get around the ugliness of the conclusion here
UPDATE / x : True : { y ; < tl > } : S  =>  { x ; { y ; < tl > } } : S

%     ITER body: Apply the body expression to each element of ty1 set. The body sequence has access to the stack.

% :: (set 'elt) : 'A   ->  'A
%    iff body :: [ 'elt : 'A -> 'A ]

----- :: set_iter_nil
ITER body / :setlist_Nil: {} : S  =>  S

body ; ITER body / x : < tl > : S => S'
----- :: set_iter_cons
ITER body / { x ; < tl > } : S  => S'

%     SIZE: Get the cardinality of the set.

% :: set 'elt : 'S -> nat : 'S

----- :: set_size_nil
SIZE / :setlist_Nil: {} : S  => :n_NatZero: 0 : S

SIZE / tl : S  =>  n : S
----- :: set_size_cons
SIZE / { d ; < tl > } : S  => :n_NatOne: 1 + n : S

% Operations on maps

%     EMPTY_MAP 'key 'val: Build ty1 new, empty map from keys of ty1 given type to values of another given type.

%     The 'key type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S -> map 'key 'val : 'S

----- :: map_empty
EMPTY_MAP cty ty / S  => :map_Nil: {} : S

%     GET: Access an element in ty1 map, returns an optional value to be checked with IF_SOME.

% :: 'key : map 'key 'val : 'S   ->   option 'val : 'S

----- :: get_empty
GET / x : :map_Nil: {} : S  =>  None : S

COMPARE / x : k : []  => :z_IntOne: 1 : []
GET / x : m : S  =>  opt_y : S
----- :: get_later
GET / x : { Elt k v ; < m > } : S  => opt_y : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: get_now
GET / x : { Elt k v ; < m > } : S  =>  Some v : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: get_nexists
GET / x : { Elt k v ; < m > } : S  =>  None : S

%     MEM: Check for the presence of ty1 binding for ty1 key in ty1 map.

% :: 'key : map 'key 'val : 'S   ->  bool : 'S

----- :: map_mem_empty
MEM / x : :map_Nil: {} : S  =>  False : S

COMPARE / x : k : []  => :z_IntOne: 1 : []
MEM / x : m : S  =>  b : S
----- :: map_mem_later
MEM / x : { Elt k v ; < m > } : S  =>  b : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: map_mem_now
MEM / x : { Elt k v ; < m > } : S  =>  True : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: map_mem_nexists
MEM / x : { Elt k v ; < m > } : S  =>  False : S

%     UPDATE: Assign or remove an element in ty1 map.

% :: 'key : option 'val : map 'key 'val : 'S   ->   map 'key 'val : 'S

----- :: map_update_false
UPDATE / x : None : :map_Nil: {} : S  => :map_Nil: {} : S

----- :: map_update_add_nexists
UPDATE / x : Some y : :map_Nil: {} : S  =>  { Elt x y } : S

COMPARE / x : k : []  => :z_IntOne: 1 : []
UPDATE / x : opt_y : m : S  =>  m' : S
----- :: map_update_cont
UPDATE / x : opt_y : { Elt k v ; < m > } : S  =>  { Elt k v ; < m' > } : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: map_update_remove
UPDATE / x : None : { Elt k v ; < m > } : S  =>  < m > : S

COMPARE / x : k : []  => :z_IntZero: 0 : []
----- :: map_update_exists
UPDATE / x : Some y : { Elt k v ; < m > } : S  =>  { Elt k y ; < m > } : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: map_update_remove_nexists
UPDATE / x : None : { Elt k v ; < m > } : S  =>  { Elt k v ; < m > } : S

COMPARE / x : k : []  =>  - :z_IntOne: 1 : []
----- :: map_update_add
UPDATE / x : Some y : { Elt k v ; < m > } : S  =>  { Elt x y ; { Elt k v ; < m > }  } : S

%     MAP body: Apply the body expression to each element of ty1 map. The body sequence has access to the stack.

% :: (map 'key 'val) : 'A   ->  (map 'key 'ty2) : 'A
%    iff   body :: [ (pair 'key 'val) : 'A -> 'ty2 : 'A ]

----- :: map_map_nil
MAP body / :map_Nil: {} : S  => :map_Nil: {} : S

%% AJ: I'm unsure how to read the conclusion of the original version
%% of this rule.  what is the meaning of applying body to (Pair k v) ?
%% This is how I interpret it.
body / k : v : S => v' : S
MAP body / m : S  => m'  : S
----- :: map_map_cons
MAP body / { Elt k v ; < m > } : S  =>  { Elt k v' ; < m' > } : S

%     ITER body: Apply the body expression to each element of ty1 map. The body sequence has access to the stack.

% :: (map 'elt 'val) : 'A   ->  'A
%    iff   body :: [ (pair 'elt 'val) : 'A -> 'A ]

----- :: map_iter_nil
ITER body / :map_Nil: {} : S  =>  S

body ; ITER body / (Pair k v) : m : S => S'
----- :: map_iter_cons
ITER body / { Elt k v ; < m > } : S  => S'

%     SIZE: Get the cardinality of the map.

% :: map 'key 'val : 'S -> nat : 'S

----- :: map_size_nil
SIZE / :map_Nil: {} : S  => :n_NatZero: 0 : S

SIZE / m : S  =>  n : S
----- :: map_size_cons
SIZE / { Elt d d' ; < m > } : S  =>  :n_NatOne: 1 + n : S

% Operations on big_maps

% AJ: I ignore these.

% The behavior of these operations is the same as if they were normal maps, except that under the hood, the elements are loaded and deserialized on demand.

%     GET: Access an element in ty1 big_map, returns an optional value to be checked with IF_SOME.

% :: 'key : big_map 'key 'val : 'S   ->   option 'val : 'S

%     MEM: Check for the presence of an element in ty1 big_map.

% :: 'key : big_map 'key 'val : 'S   ->  bool : 'S

%     UPDATE: Assign or remove an element in ty1 big_map.

% :: 'key : option 'val : big_map 'key 'val : 'S   ->   big_map 'key 'val : 'S

%%
%% Operations on optional values
%%

%     SOME: Pack ty1 present optional value.

% :: 'ty1 : 'S   ->   option 'ty1 : 'S

----- :: some
SOME / v : S  =>  (Some v) : S

%     NONE 'ty1: The absent optional value.

% :: 'S   ->   option 'ty1 : 'S

----- :: none
NONE ty / v : S  =>  None : S

%     IF_NONE body1 body2: Inspect an optional value.

% :: option 'ty1 : 'S   ->   'ty2 : 'S
%    iff   body1 :: [ 'S -> 'ty2 : 'S]
%          body2 :: [ 'ty1 : 'S -> 'ty2 : 'S]

body1 / S => S'
----- :: if_none
IF_NONE body1 body2 / None : S => S'

body2 / d : S => S'
----- :: if_some
IF_NONE body1 body2 / (Some d) : S =>  S'

% Operations on unions

%     LEFT 'ty2: Pack ty1 value in ty1 union (left case).

% :: 'ty1 : 'S   ->   or 'ty1 'ty2 : 'S

----- :: pack_left
LEFT ty / v : S  =>  (Left v) : S

%     RIGHT 'ty1: Pack ty1 value in ty1 union (right case).

% :: 'ty2 : 'S   ->   or 'ty1 'ty2 : 'S

----- :: pack_right
RIGHT ty / v : S  =>  (Right v) : S

%     IF_LEFT body1 body2: Inspect ty1 value of ty1 variant type.

% :: or 'ty1 'ty2 : 'S   ->   'cty : 'S
%    iff   body1 :: [ 'ty1 : 'S -> 'cty : 'S]
%          body2 :: [ 'ty2 : 'S -> 'cty : 'S]

body1 / d : S => S'
----- :: if_left_left
IF_LEFT body1 body2 / (Left d) : S  =>  S'

body2 / d : S => S'
----- :: if_left_right
IF_LEFT body1 body2 / (Right d) : S  => S'

%     IF_RIGHT body1 body2: Inspect ty1 value of ty1 variant type.

% :: or 'ty1 'ty2 : 'S   ->   'cty : 'S
%    iff   body1 :: [ 'ty2 : 'S -> 'cty : 'S]
%          body2 :: [ 'ty1 : 'S -> 'cty : 'S]

body1 / d : S => S'
----- :: if_right_right
IF_RIGHT body1 body2 / (Right d) : S  => S'

body2 / d : S => S'
----- :: if_right_left
IF_RIGHT body1 body2 / (Left d) : S  =>  S'

% Operations on lists

%     CONS: Prepend an element to ty1 list.

% :: 'ty1 : list 'ty1 : 'S   ->   list 'ty1 : 'S

----- :: cons
CONS / d : tl : S  =>  { d ; < tl > } : S

%     NIL 'ty1: The empty list.

% :: 'S   ->   list 'ty1 : 'S

----- :: nil
NIL ty / S  => :setlist_Nil: {} : S

%     IF_CONS body1 body2: Inspect an optional value.

% :: list 'ty1 : 'S   ->   'ty2 : 'S
%    iff   body1 :: [ 'ty1 : list 'ty1 : 'S -> 'ty2 : 'S]
%          body2 :: [ 'S -> 'ty2 : 'S]

body2 / S => S'
----- :: if_cons_nil
IF_CONS body1 body2 / :setlist_Nil: {} : S  =>  S'

body1 / d : tl : S => S'
----- :: if_cons_cons
IF_CONS body1 body2 / { d ; < tl > }  : S  => S'

%     MAP body: Apply the body expression to each element of the list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  (list 'ty2) : 'A
%    iff   body :: [ 'elt : 'A -> 'ty2 : 'A ]

body / d : S => d' : S
MAP body / tl : S  => tl' : S
----- :: list_map_cons
MAP body / { d ; < tl > }  : S  =>  { d' ; < tl' > } : S

----- :: list_map_nil
MAP body / :setlist_Nil: {} : S  => :setlist_Nil: {} : S

%     SIZE: Get the number of elements in the list.

% :: list 'elt : 'S -> nat : 'S

----- :: list_size_nil
SIZE / :setlist_Nil: {} : S  => :n_NatZero: 0 : S

SIZE / tl  : S  =>  n : S
----- :: list_size_cons
SIZE / { d ; <tl> } : S  =>  :n_NatOne: 1 + n : S

%     ITER body: Apply the body expression to each element of ty1 list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  'A
%      iff body :: [ 'elt : 'A -> 'A ]

body ; ITER body / d : tl : S => S'
----- :: list_iter_cons
ITER body / { d ; <tl> } : S  =>  S'

----- :: list_iter_nil
ITER body / :setlist_Nil: {} : S  =>  S

embed {{coq
End syntax.
}}
