% Such embed sections are extracted to directly to the michelson.v and
% are used to import external modules.
embed {{ coq
Require Import ZArith.
Require Import String.

Require Import List.
Import ListNotations.
}}

grammar

%%
%% 1. Grammar
%%
%% The grammar specifies: the basic data types of ott; sets, lists and
%% maps; and instructions and stacks. It also specifies how they map
%% to Coq. Other proof assistants can also be targetted
%% simultaneously, but I've used Coq as an example.
%%

% Basic data types. These are translated directly to Coq equivalents,
% as specified by the {{ coq }} annotations. The {{ phantom }}
% annotations specifies to generate no inductive type.


%% E.g., we specify that booleans, can be referred to by the
%% meta-variables bool, b and r. In coq, they are represented by the
%% coq type bool, hence no need to generated an inductive definition.
bool, b, r :: 'b_' ::= {{ coq bool }} {{ phantom }}
     | True :: M :: True
     {{ coq true }}
     | False :: M :: False
     {{ coq false }}
     | ( b1 bop b2 ) :: M :: Bop
     {{ coq ( [[bop]] [[b1]] [[b2]] ) }}
     | ! b2  :: M :: Neg
     {{ coq ( negb [[b2]] ) }}

nat, n :: 'z_' ::= {{ coq nat }} {{ phantom }}
  | 0n :: M :: NatZero {{ coq 0 }}
  | 1n :: M :: NatOne {{ coq 1 }}
  | 256n :: M :: NatMaxByte
  {{ coq 256 }}
  | length s :: M :: StringLength
  {{ coq (String.length s) }}
  | abs z :: M :: Abs
  {{ coq (Z.abs_nat [[z]]) }}

int, z :: 'z_' ::= {{ coq Z }} {{ phantom }}
  | 0z :: M :: IntZero {{ coq 0 }}
  | 1z :: M :: IntOne {{ coq 1 }}

string_lit , s , t :: 's_' ::= {{ coq string }} {{ phantom }}
     | ( s ^ s' ) :: M :: Concat
     {{ coq (append [[s]] [[s']]) }}
     | "" :: M :: StringEmpty
     {{ coq ("") }}
     | slice s n n' :: M :: StringSlice
     {{ coq (substring [[n]] [[n']] [[s]]) }}

%% Now starts real data-types, which will be translated by inductive
%% types.

% I use a sum type "num" to regroup integers and naturals. This allows
% me to have some rules of the semantics defined only for values that
% is either a integer a natural, even though I haven't implemented
% type checking.

num, N :: 'N_' ::=
  | z :: :: IntConstant
  | n :: :: NatConstant
  % meta-productions: these specifies productions that do not give
  % rise the constructors of the data type, but instead are translated
  % directly into proof assitant code. This is very handy for giving
  % functions on the data-types. num_apply_aop, num_apply_bitop are
  % functions that must be specified in the Coq development.
  | N aop N' :: M :: Aop
  {{ coq ( num_apply_aop [[aop]] [[N]] [[N']] ) }}
  | N bitop N' :: M :: Bitop
  {{ coq ( num_apply_bitop [[bitop]] [[N]] [[N']] ) }}
  | - N :: M :: NumNeg
  {{ coq ( num_neg [[N]] ) }}
  | ~ N :: M :: BitNeg
  {{ coq ( num_bit_neg [[N]] ) }}

%% Lists and sets are represented directly to Coq list. Maps are
%% represented by list of key-value pairs. [[ d ; dl ]] is a list,
%% { s : set } a set and [ (Elt d d') ; map ] a map.

data_list, dl, l :: 'dl_' ::= {{ coq list data }} {{ phantom }}
     | [[]] :: :: Nil
     {{ coq []  }}
     | [[ d ; dl ]] :: :: Cons
     {{ coq ([[d]] :: [[dl]])  }}
     % meta-productions
     | [[ d ]]  :: M :: Singleton
     {{ coq [ [[d]] ]  }}
     % this is just syntatic sugar to have ott definitions and ascii
     % rules look similar.
     | < l > :: M :: Chevron
     {{ coq [[l]] }}


set :: 'set_' ::= {{ coq list data }} {{ phantom }}
     | {} :: M :: Nil
     {{ coq []  }}
     | { d ; set } :: M :: Cons
     {{ coq ([[d]] :: [[set]])  }}
     % meta-productions
     | { d }  :: M :: Singleton
     {{ coq [ [[d]] ]  }}
     | < set > :: M :: Chevron
     {{ coq [[set]] }}

%% Note: I use [] as syntax for maps instead of {} to avoid clash with
%% sets.
map :: 'map_' ::= {{ coq list (data * data) }} {{ phantom }}
     % meta-productions
     | [] :: M :: Nil
     {{ coq [] }}
     % | { Elt d1 d1'  ; .. ; Elt dm dm' } :: :: Map
     | [ Elt d d' ; map ]  :: M :: Cons
     {{ coq (([[d]], [[d']])::[[map]]) }}
     | [ Elt d d' ]  :: M :: Singleton
     {{ coq [ ([[d]], [[d']]) ] }}
     | < map > :: M :: Chevron
     {{ coq [[map]] }}

% Operators: note that I use different symbols for boolean and bit
% operations, unlike the michelson documentation. In ott, it is
% necessary to distinguish the operations to apply the correct rule
% transformations to proof assitant code.

bop :: 'bop_' ::= {{ coq bool -> bool -> bool }} {{ phantom }}
    | || :: :: Or {{ coq orb }}
    | && :: :: And {{ coq andb }}
    | xor :: :: Xor {{ coq xorb }}

aop :: 'aop_' ::=
    | + :: :: Add
    | - :: :: Sub
    | * :: :: Mul
    | / :: :: Div
    | % :: :: Mod
    | << :: :: Lsl
    | >>> :: :: Lsr

bitop :: 'bitop_' ::=
    | | :: :: Or
    | & :: :: And
    | ^ :: :: Xor

% Note that the grammar for data is quite close to grammar given of
% the documentation, except that the numerals are regrouped by Num.
data, d, x, y, hd, k, v, opt_y :: 'd_' ::=
     | N :: :: Num
     | s :: :: StringConstant
     | Unit :: :: Unit
     | b :: :: BoolConstant
     | Pair d d' :: :: Pair
     | Left d :: :: Left
     | Right d :: :: Right
     | Some d :: :: Some
     | None :: :: None
     | dl :: :: DataList
     | set :: :: Set
     | map :: :: Map
     | instruction :: :: Instruction

     %% meta-rules
     | ( d ) :: M :: Paren
     {{ coq ( [[d]] ) }}


% A stackerr is either failed or a stack, which is a list of data.
stackerr, SE :: 'SE_' ::=
       | [FAILED] :: :: Failed
       | stack :: :: Stack

%% TODO: This could probably be represented by a data list instead.
stack, S :: 'S_' ::= {{coq list data }} {{ phantom }}
       | [] :: M :: Nil
       {{ coq [] }}
       | d : S :: M :: Cons
       {{ coq ([[d]] :: [[S]]) }}

%% ctype and type are also present in the grammar, but have no meaning
%% in the semantics.
ctype, ct :: 'ct_' ::=
  | int_type :: :: Int
  | nat_type :: :: Nat
  | string :: :: String
  % Nevertheless, i've hidden the types not used.
  % | tez :: :: Tez
  | bool_type :: :: Bool
  % | key_hash :: :: Key
  % | timestamp :: :: Timestamp

type, ty :: 't_' ::=
  | ct :: :: Ct
  | key :: :: Key
  | unit :: :: Unit
  | signature :: :: Signature
  | option t :: :: Option
  | list t :: :: List
  | type_set ct :: :: Set
  | operation :: :: Operation
  | contract t :: :: Contract
  | pair t t' :: :: Pair
  | or t t' :: :: Or
  | lambda t t' :: :: Lambda
  | type_map ct t :: :: Map
  | big_map ct t :: :: Big

% The instructions are very similar to the ones given by the grammar.
% One difference is that I use the sequence operator instead of lists
% of instructions. The reason is that there is no rules in the
% language for dealing with the execution of an empty sequence, and I
% didn't want to add any new rules.
instruction, body, bt, bf, i :: 'i_' ::=
     | i ; i' :: :: Seq
     | DROP :: :: Drop
     | DUP :: :: Dup
     | SWAP :: :: Swap
     | PUSH ty d :: :: Push
     | SOME :: :: Some
     | NONE ty :: :: None
     | UNIT :: :: Unit
     | IF_NONE i i' :: :: IfNone
     | PAIR :: :: Pair
     | CAR :: :: Car
     | CDR :: :: Cdr
     | LEFT ty :: :: Left
     | RIGHT ty :: :: Right
     | IF_LEFT i i' :: :: IfLeft
     | IF_RIGHT i i' :: :: IfRight
     | NIL ty :: :: Nil
     | CONS :: :: Cons
     | IF_CONS i i' :: :: IfCons
     | EMPTY_SET ty :: :: EmptySet
     | EMPTY_MAP ct ty :: :: EmptyMap
     | MAP i :: :: Map
     | ITER i :: :: Iter
     | MEM :: :: Mem
     | GET :: :: Get
     | UPDATE :: :: Update
     | IF i i' :: :: If
     | LOOP i :: :: Loop
     | LOOP_LEFT i :: :: LoopLeft
     | LAMBDA ty ty' i :: :: Lambda
     | EXEC :: :: Exec
     | DIP i :: :: Dip
     | FAILWITH :: :: Failwith
     | CAST :: :: Cast
     | RENAME :: :: Rename
     | CONCAT :: :: Concat
     | ADD :: :: Add
     | SUB :: :: Sub
     | MUL :: :: Mul
     | DIV :: :: Div
     | EDIV :: :: EDiv %% Added
     | ABS :: :: Abs
     | NEG :: :: Neg
     | MOD :: :: Mod
     | LSL :: :: Lsl
     | LSR :: :: Lsr
     | OR :: :: Or
     | AND :: :: And
     | XOR :: :: Xor
     | NOT :: :: Not
     | COMPARE :: :: Compare
     | SIZE :: :: Size      %% Added
     | SLICE :: :: Slice      %% Added
     | EQ :: :: Eq
     | NEQ :: :: Neq
     | LT :: :: Lt
     | GT :: :: Gt
     | LE :: :: Le
     | GE :: :: Ge
     | INT :: :: Int
     | SELF :: :: Self
     | TRANSFER_TOKENS :: :: Transfer
     | SET_DELEGATE :: :: Set
     | CREATE_ACCOUNT :: :: CreateAccount
     | CREATE_CONTRACT :: :: CreateContract
     | IMPLICIT_ACCOUNT :: :: Implicit
     | NOW :: :: Now
     | AMOUNT :: :: Amount
     | BALANCE :: :: Balance
     | CHECK_SIGNATURE :: :: Check
     | BLAKE2B :: :: Blake2b
     | HASH_KEY :: :: Hash
     | STEPS_TO_QUOTA :: :: Steps
     | SOURCE :: :: Source
     | SENDER :: :: Sender

%%
%% 2. Formulas
%%
%% The formulas specify what can be used as premisses in the inference
%% rules of the semantics of the 3rd section. The first formula
%% indicates that judgements of the semantics can be used as premises
%% for new judgements. The remaining premises specify relations
%% between data types of Michelsson and how they translate to Coq. The
%% translation to Coq of the relations is incomplete.
%%

formula :: formula_ ::=
	| judgement :: :: judgement

    | N = N'  :: :: num_eq
    {{ coq lift_num2 (@eq) [[N]] [[N']] }}
    | N < N'  :: :: num_lt
    {{ coq lift_num lt Z.lt [[N]] [[N']] }}
    | N <= N'  :: :: num_le
    {{ coq lift_num le Z.le [[N]] [[N']] }}
    | N > N'  :: :: num_gt
    {{ coq lift_num gt Z.gt [[N]] [[N']] }}
    | N >= N'  :: :: num_ge
    {{ coq lift_num ge Z.ge [[N]] [[N']] }}

    % the "# Num" part of these formulas is only used to separate
    % this <> from the <> on data types.
    | N <> 0N # Num :: :: num_neq_zero
    {{ coq num_neq_zero [[N]] }}
    | N <> N' # Num :: :: num_neq
    {{ coq lift_num2 (fun (A : Type) (d d' : A) =>
                            not (d = d')) [[N]] [[N']] }}

    % A bit ugly, i lift this formula to data
    | d <> d'  :: :: data_neq
    {{ coq [[d]] <> [[d']] }}

    % Strings can also be compared
    | s < t :: :: str_lt
    {{ coq TODO }}
    | s = t :: :: str_eq
    {{ coq TODO }}
    | s > t :: :: str_gt
    {{ coq TODO }}

% The implementation of the coq definitions mentioned for formulas
% will be included in the generated Coq files:

embed {{ coq

Load Formulas.
}}

%%
%% 3. Judgements
%%

defns
Op :: '' ::=


%% A big-step goes from an instruction (which is possible a sequence
%% of instructions), an initial stack to a final stack.

% Local big-step rules
defn
instruction / stackerr => stackerr'  :: :: BigStep :: 'bs_'
{{ tex [[instruction]] / [[stackerr]] \Rightarrow [[stackerr']] }}
by


%%
%% Now follows the rules. As far as possible, I follow the look of the
%% rules in the Michelson documentation. However, premises are here placed
%% above the line "------- :: [rule_name]" and the sugar
%%
%%   i / S => i' / S'
%%
%%  is desugered to
%%
%% i' / S => S'
%% -------- ::
%% i / S => S'
%%
%% I've left the typing rules, not implemented, in comment, and some bits of the original documentation.
%% My comments are prefixed AJ:.
%%

------ :: failwith
FAILWITH / d : stack => [FAILED]

------ :: failed
i / [FAILED] => [FAILED]


i1 / S => SE''
i2 / SE'' => SE'
------ :: sequence
i1 ; i2 / S => SE'

i1 / S => S'
------ :: if_tt
IF i1 i2 / True : S => S'

i2 / S => S'
------ :: if_ff
IF i1 i2 / False : S => S'

i1 ; LOOP i1 / S => S'
------ :: loop_tt
LOOP i1 / True : S => S'

------ :: loop_ff
LOOP i1 / False : S => S

i1 ; LOOP_LEFT i1 / d : S => S'
------ :: loop_left_tt
LOOP_LEFT i1 / Left d : S => S'

i1 / S => S'
------ :: dip
DIP i1 / d : S => d : S'

i / d2 : []  =>  d3 : []
------ :: exec
EXEC / i : d2 : S  =>  d3 : S


%%
%% Stack operations
%%
%     DROP: Drop the top element of the stack.

% :: _ : 'A   ->   'A

----- :: drop
DROP / d : S  =>  S

%     DUP: Duplicate the top of the stack.

% :: 'a : 'A   ->   'a : 'a : 'A

----- :: dup
DUP / d : S  =>  d : d : S

%     SWAP: Exchange the top two elements of the stack.

% :: 'a : 'b : 'A   ->   'b : 'a : 'A

----- :: swap
SWAP / d1 : d2 : S  =>  d2 : d1 : S

%     PUSH 'a x: Push a constant value of a given type onto the stack.

% :: 'A   ->   'a : 'A
%    iff   x :: 'a

----- :: push
PUSH ty d / S  =>  d : S

%     UNIT: Push a unit value onto the stack.

% :: 'A   ->   unit : 'A

----- :: unit
UNIT / S  =>  Unit : S

%     LAMBDA 'a 'b code: Push a lambda with given parameter and return types onto the stack.

% :: 'A ->  (lambda 'a 'b) : 'A

----- :: lambda
LAMBDA ty ty' i / S  =>  i : S


%%
%% Generic comparison
%%

%     EQ: Checks that the top of the stack EQuals zero.

% :: int : 'S   ->   bool : 'S

----- :: eq_tt
EQ / 0z : S  =>  True : S

z <> 0z # Num
----- :: eq_ff
EQ / z : S  =>  False : S

%     NEQ: Checks that the top of the stack does Not EQual zero.

% :: int : 'S   ->   bool : 'S

----- :: neq_ff
NEQ / 0z : S  =>  False : S

z <> 0z # Num
----- :: neq_tt
NEQ / z : S  =>  True : S

%     LT: Checks that the top of the stack is Less Than zero.

% :: int : 'S   ->   bool : 'S

z < 0z
----- :: lt_tt
LT / z : S  =>  True : S

z >= 0z
----- :: lt_ff
LT / z : S  =>  False : S

%     GT: Checks that the top of the stack is Greater Than zero.

% :: int : 'S   ->   bool : 'S


z > 0z
----- :: gt_tt
GT / z : S  =>  True : S

z <= 0z
----- :: gt_ff
GT / z : S  =>  False : S

%     LE: Checks that the top of the stack is Less Than of Equal to zero.

% :: int : 'S   ->   bool : 'S

z <= 0z
----- :: le_tt
LE / z : S  =>  True : S

z > 0z
----- :: le_ff
LE / z : S  =>  False : S

%     GE: Checks that the top of the stack is Greater Than of Equal to zero.

% :: int : 'S   ->   bool : 'S


z >= 0z
----- :: ge
GE / z : S  =>  True : S

z < 0z
----- :: lt
GE / z : S  =>  False : S


% V - Operations
% Operations on booleans

%     OR

% :: bool : bool : 'S   ->   bool : 'S


----- :: or
OR / b1 : b1 : S  =>  ( b1 || b2 ) : S

%     AND

% :: bool : bool : 'S   ->   bool : 'S


----- :: and
AND / b1 : b2 : S  =>  ( b1 && b2 ) : S

%     XOR

% :: bool : bool : 'S   ->   bool : 'S

----- :: xor
XOR / b1 : b2 : S  =>  ( b1 xor b2 ) : S

%     NOT

% :: bool : 'S   ->   bool : 'S

----- :: not
NOT / b : S  =>  ! b : S

% Operations on integers and natural numbers

% Integers and naturals are arbitrary-precision, meaning the only size limit is fuel.

%     NEG

% :: int : 'S   ->   int : 'S
% :: nat : 'S   ->   int : 'S

----- :: neg
NEG / N : S  =>  - N : S

%     ABS

% :: int : 'S   ->   nat : 'S

----- :: abs
ABS / z : S  =>  abs z : S

%     ADD

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: add
ADD / N : N' : S  =>  (N + N') : S

%     SUB

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

----- :: sub
SUB / N : N' : S  =>  ( N - N' ) : S

%     MUL

% :: int : int : 'S   ->   int : 'S
% :: int : nat : 'S   ->   int : 'S
% :: nat : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   nat : 'S

----- :: mul
MUL / N : N' : S  =>  ( N * N' ) : S

%     EDIV Perform Euclidian division

% :: int : int : 'S   ->   option (pair int nat) : 'S
% :: int : nat : 'S   ->   option (pair int nat) : 'S
% :: nat : int : 'S   ->   option (pair int nat) : 'S
% :: nat : nat : 'S   ->   option (pair nat nat) : 'S


N <> 0N # Num
----- :: ediv_0
EDIV / N : N' : S  =>  None : S

N <> 0N # Num
----- :: ediv
EDIV / N : N' : S  =>  Some ( Pair ( N / N' ) ( N % N' )) : S

% Bitwise logical operators are also available on unsigned integers.

%     OR

% :: nat : nat : 'S   ->   nat : 'S

----- :: bit_or
OR / n : n' : S  =>  ( n | n' ) : S

%     AND (also available when the top operand is signed)

% :: nat : nat : 'S   ->   nat : 'S
% :: int : nat : 'S   ->   nat : 'S

----- :: bit_and
AND / N : N' : S  =>  ( N & N' ) : S

%     XOR

% :: nat : nat : 'S   ->   nat : 'S

----- :: bit_xor
XOR / n : n' : S  =>  ( n ^ n' ) : S

%     Michelson Documentation: NOT The return type of NOT is an int and not a nat. This is because the sign is also negated. The resulting integer is computed using two’s complement. For instance, the boolean negation of 0 is -1. To get a natural back, a possibility is to use AND with an unsigned mask afterwards.

% :: nat : 'S   ->   int : 'S
% :: int : 'S   ->   int : 'S

----- :: bit_not
NOT / N : S  =>  ~ N : S

%     LSL

% :: nat : nat : 'S   ->   nat : 'S

n' <= 256n
----- :: lsl
LSL / n : n' : S  =>  ( n << n' ) : S

n' > 256n
----- :: lsl_fail
LSL / n : n' : S  =>  [FAILED]

%     LSR

% :: Nat : nat : 'S   ->   nat : 'S

----- :: lsr
LSR / n : n' : S  =>  ( n >>> n' ) : S

%     COMPARE: Integer/natural comparison

% :: int : int : 'S   ->   int : 'S
% :: nat : nat : 'S   ->   int : 'S

N < N'
----- :: compare_num_lt
COMPARE / N : N' : S  =>  -1z : S

N = N'
----- :: compare_num_eq
COMPARE / N : N' : S  =>  0z : S

N > N'
----- :: compare_num_gt
COMPARE / N : N' : S  =>  1z : S

% Operations on strings

% Michelson Documentation: Strings are mostly used for naming things without having to rely on external ID databases. They are restricted to the printable subset of 7-bit ASCII, plus some escaped characters (see section on constants). So what can be done is basically use string constants as is, concatenate or splice them, and use them as keys.

%     CONCAT: String concatenation.

% :: string : string : 'S   -> string : 'S

----- :: concat_string
CONCAT / s : t : S  =>  ( s ^ t ) : S

% :: string list : 'S   -> string : 'S

----- :: concat_list_nil
CONCAT / [[]] : S  =>  "" : S

CONCAT / < l > : S  =>  t : S
----- :: concat_list_cons
CONCAT / [[ s ; < l > ]] : S  =>  ( s ^ t ) : S

%     SIZE: number of characters in a string.

% :: string : 'S   ->   nat : 'S

----- :: size_string
SIZE / s : S  =>  ( length s ) : S

%     SLICE: String access.

%         :: nat : nat : string : ‘S -> option string : ‘S




% n: length
% n': offset
n + n' < length s
----- :: slice_some
SLICE / n : n' : s : S => Some ( slice s n n' ) : S

%             where ss is the substring of s at the given offset and of the given length

%                 iff offset and (offset + length) are in bounds

% n: length
% n': offset
n + n' >= length s
----- :: slice
SLICE / n : n' : s : S => None : S

%             iff offset or (offset + length) are out of bounds

%     COMPARE: Lexicographic comparison.

% :: string : string : 'S   ->   int : 'S

s < t
----- :: compare_string_lt
COMPARE / s : t : S  =>  -1z : S

s = t
----- :: compare_string_eq
COMPARE / s : t : S  =>  0z : S

s > t
----- :: compare_string_gt
COMPARE / s : t : S  =>  1z : S

% Operations on pairs

%     PAIR: Build a pair from the stack’s top two elements.

% :: 'a : 'b : 'S   ->   pair 'a 'b : 'S

----- :: pair
PAIR / d : d' : S  =>  ( Pair d d' ) : S

%     CAR: Access the left part of a pair.

% :: pair 'a _ : 'S   ->   'a : 'S

----- :: car
CAR / ( Pair d d' ) : S  =>  d : S

%     CDR: Access the right part of a pair.

% :: pair _ 'b : 'S   ->   'b : 'S

----- :: cdr
CDR / ( Pair d d' ) : S  =>  d' : S

% Operations on sets

%     EMPTY_SET 'elt: Build a new, empty set for elements of a given type.

%     The 'elt type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S   ->   set 'elt : 'S

----- :: set_empty
EMPTY_SET ty / S  =>  {} : S

%     MEM: Check for the presence of an element in a set.

% :: 'elt : set 'elt : 'S   ->  bool : 'S

----- :: set_mem_empty
MEM / x : {} : S  =>  False : S

COMPARE / x : y : []  =>  1z : []
% AJ: The original rule was:
% MEM / x : v : { < tl > } : S  =>  r : S
% i don't see where the v comes from. i think it is an error. See remarks of README.
MEM / x : set : S   =>  b : S
----- :: set_mem_later
MEM / x : { y ; < set > } : S  =>  b : S

COMPARE / x : y : []  =>  0z : []
----- :: set_mem_found
MEM / x : { y ; < set > } : S  =>  True : S

COMPARE / x : y : []  =>  -1z : []
----- :: set_mem_nexists
MEM / x : { y ; < set > } : S  =>  False : S

%     UPDATE: Inserts or removes an element in a set, replacing a previous value.

% :: 'elt : bool : set 'elt : 'S   ->   set 'elt : 'S

----- :: set_update_false
UPDATE / x : False : {} : S  =>  {} : S

----- :: set_update_add_nexists
UPDATE / x : True : {} : S  =>  { x } : S

COMPARE / x : d : []  =>  1z : []
UPDATE / x : b : set : S  =>  set' : S
----- :: set_update_cont
UPDATE / x : b : { y ; < set > } : S  =>  { y ; < set' > } : S

COMPARE / x : y : []  =>  0z : []
----- :: set_update_remove
UPDATE / x : False : { y ; < set > } : S  =>  set : S

COMPARE / x : y : []  =>  0z : []
----- :: set_update_exists
UPDATE / x : True : { y ; < set > } : S  =>  { y ; < set > } : S

COMPARE / x : y : []  =>  -1z : []
----- :: set_update_remove_nexists
UPDATE / x : False : { y ; < set > } : S  =>  { y ; < set > } : S

COMPARE / x : y : []  =>  -1z : []
----- :: set_update_add
%% AJ: not sure how to get around the ugliness of the conclusion here
UPDATE / x : True : { y ; < set > } : S  =>  { x ; { y ; < set > } } : S

%     ITER body: Apply the body expression to each element of a set. The body sequence has access to the stack.

% :: (set 'elt) : 'A   ->  'A
%    iff body :: [ 'elt : 'A -> 'A ]

----- :: set_iter_nil
ITER body / {} : S  =>  S

body ; ITER body / hd : < set > : S => S'
----- :: set_iter_cons
ITER body / { hd ; < set > } : S  => S'

%     SIZE: Get the cardinality of the set.

% :: set 'elt : 'S -> nat : 'S

----- :: set_size_nil
SIZE / {} : S  =>  0n : S

SIZE / { < set > } : S  =>  n : S
----- :: set_size_cons
SIZE / { d ; < set > } : S  =>  1n + n : S

% Operations on maps

%     EMPTY_MAP 'key 'val: Build a new, empty map from keys of a given type to values of another given type.

%     The 'key type must be comparable (the COMPARE primitive must be defined over it).

% :: 'S -> map 'key 'val : 'S

----- :: map_empty
EMPTY_MAP ct ty / S  =>  [] : S

%     GET: Access an element in a map, returns an optional value to be checked with IF_SOME.

% :: 'key : map 'key 'val : 'S   ->   option 'val : 'S

----- :: get_empty
GET / x : [] : S  =>  None : S

COMPARE / x : k : []  =>  1z : []
GET / x : < map >  : S  =>  opt_y : S
----- :: get_later
GET / x : [ Elt k v ; < map > ] : S  =>  opt_y : S

COMPARE / x : k : []  =>  0z : []
----- :: get_now
GET / x : [ Elt k v ; < map > ] : S  =>  Some v : S

COMPARE / x : k : []  =>  -1z : []
----- :: get_nexists
GET / x : [ Elt k v ; < map > ] : S  =>  None : S

%     MEM: Check for the presence of a binding for a key in a map.

% :: 'key : map 'key 'val : 'S   ->  bool : 'S

----- :: map_mem_empty
MEM / x : [] : S  =>  False : S

COMPARE / x : k : []  =>  1z : []
MEM / x : < map > : S  =>  r : S
----- :: map_mem_later
MEM / x : [ Elt k v ; < map > ] : S  =>  r : S

COMPARE / x : k : []  =>  0z : []
----- :: map_mem_now
MEM / x : [ Elt k v ; < map > ] : S  =>  True : S

COMPARE / x : k : []  =>  -1z : []
----- :: map_mem_nexists
MEM / x : [ Elt k v ; < map > ] : S  =>  False : S

%     UPDATE: Assign or remove an element in a map.

% :: 'key : option 'val : map 'key 'val : 'S   ->   map 'key 'val : 'S

----- :: map_update_false
UPDATE / x : None : [] : S  =>  [] : S

----- :: map_update_add_nexists
UPDATE / x : Some y : [] : S  =>  [ Elt x y ] : S

COMPARE / x : k : []  =>  1z : []
UPDATE / x : opt_y : < map > : S  =>  < map' > : S
----- :: map_update_cont
UPDATE / x : opt_y : [ Elt k v ; < map > ] : S  =>  [ Elt k v ; < map' > ] : S

COMPARE / x : k : []  =>  0z : []
----- :: map_update_remove
UPDATE / x : None : [ Elt k v ; < map > ] : S  =>  < map > : S

COMPARE / x : k : []  =>  0z : []
----- :: map_update_exists
UPDATE / x : Some y : [ Elt k v ; < map > ] : S  =>  [ Elt k y ; < map > ] : S

COMPARE / x : k : []  =>  -1z : []
----- :: map_update_remove_nexists
UPDATE / x : None : [ Elt k v ; < map > ] : S  =>  [ Elt k v ; < map > ] : S

COMPARE / x : k : []  =>  -1z : []
----- :: map_update_add
UPDATE / x : Some y : [ Elt k v ; < map > ] : S  =>  [ Elt x y ; [ Elt k v ; < map > ]  ] : S

%     MAP body: Apply the body expression to each element of a map. The body sequence has access to the stack.

% :: (map 'key 'val) : 'A   ->  (map 'key 'b) : 'A
%    iff   body :: [ (pair 'key 'val) : 'A -> 'b : 'A ]

----- :: map_map_nil
MAP body / [] : S  =>  [] : S

%% AJ: I'm unsure how to read the conclusion of the original version
%% of this rule.  what is the meaning of applying body to (Pair k v) ?
%% This is how I interpret it.
body / k : v : S => v' : S
MAP body / < map > : S  =>   < map' >  : S
----- :: map_map_cons
MAP body / [ Elt k v ; < map > ] : S  =>  [ Elt k v' ; < map' > ] : S

%     ITER body: Apply the body expression to each element of a map. The body sequence has access to the stack.

% :: (map 'elt 'val) : 'A   ->  'A
%    iff   body :: [ (pair 'elt 'val) : 'A -> 'A ]

----- :: map_iter_nil
ITER body / [] : S  =>  S

body ; ITER body / (Pair k v) : < map > : S => S'
----- :: map_iter_cons
ITER body / [ Elt k v ; < map > ] : S  => S'

%     SIZE: Get the cardinality of the map.

% :: map 'key 'val : 'S -> nat : 'S

----- :: map_size_nil
SIZE / [] : S  =>  0n : S

SIZE / < map > : S  =>  n : S
----- :: map_size_cons
SIZE / [ Elt d d' ; < map > ] : S  =>  1n + n : S

% Operations on big_maps

% AJ: I ignore these.

% The behavior of these operations is the same as if they were normal maps, except that under the hood, the elements are loaded and deserialized on demand.

%     GET: Access an element in a big_map, returns an optional value to be checked with IF_SOME.

% :: 'key : big_map 'key 'val : 'S   ->   option 'val : 'S

%     MEM: Check for the presence of an element in a big_map.

% :: 'key : big_map 'key 'val : 'S   ->  bool : 'S

%     UPDATE: Assign or remove an element in a big_map.

% :: 'key : option 'val : big_map 'key 'val : 'S   ->   big_map 'key 'val : 'S

%%
%% Operations on optional values
%%

%     SOME: Pack a present optional value.

% :: 'a : 'S   ->   option 'a : 'S

----- :: some
SOME / v : S  =>  (Some v) : S

%     NONE 'a: The absent optional value.

% :: 'S   ->   option 'a : 'S

----- :: none
NONE ty / v : S  =>  None : S

%     IF_NONE bt bf: Inspect an optional value.

% :: option 'a : 'S   ->   'b : 'S
%    iff   bt :: [ 'S -> 'b : 'S]
%          bf :: [ 'a : 'S -> 'b : 'S]

bt / S => S'
----- :: if_none
IF_NONE bt bf / None : S => S'

bf / d : S => S'
----- :: if_some
IF_NONE bt bf / (Some d) : S =>  S'

% Operations on unions

%     LEFT 'b: Pack a value in a union (left case).

% :: 'a : 'S   ->   or 'a 'b : 'S

----- :: pack_left
LEFT ty / v : S  =>  (Left v) : S

%     RIGHT 'a: Pack a value in a union (right case).

% :: 'b : 'S   ->   or 'a 'b : 'S

----- :: pack_right
RIGHT ty / v : S  =>  (Right v) : S

%     IF_LEFT bt bf: Inspect a value of a variant type.

% :: or 'a 'b : 'S   ->   'c : 'S
%    iff   bt :: [ 'a : 'S -> 'c : 'S]
%          bf :: [ 'b : 'S -> 'c : 'S]

bt / d : S => S'
----- :: if_left_left
IF_LEFT bt bf / (Left d) : S  =>  S'

bf / d : S => S'
----- :: if_left_right
IF_LEFT bt bf / (Right d) : S  => S'

%     IF_RIGHT bt bf: Inspect a value of a variant type.

% :: or 'a 'b : 'S   ->   'c : 'S
%    iff   bt :: [ 'b : 'S -> 'c : 'S]
%          bf :: [ 'a : 'S -> 'c : 'S]

bt / d : S => S'
----- :: if_right_right
IF_RIGHT bt bf / (Right d) : S  => S'

bf / d : S => S'
----- :: if_right_left
IF_RIGHT bt bf / (Left d) : S  =>  S'

% Operations on lists

%     CONS: Prepend an element to a list.

% :: 'a : list 'a : 'S   ->   list 'a : 'S

----- :: cons
CONS / d : < l >  : S  =>  [[ d ; < l > ]] : S

%     NIL 'a: The empty list.

% :: 'S   ->   list 'a : 'S

----- :: nil
NIL ty / S  => [[]] : S

%     IF_CONS bt bf: Inspect an optional value.

% :: list 'a : 'S   ->   'b : 'S
%    iff   bt :: [ 'a : list 'a : 'S -> 'b : 'S]
%          bf :: [ 'S -> 'b : 'S]

bt / d : < l > : S => S'
----- :: if_cons_cons
IF_CONS bt bf / [[ d ; < l > ]]  : S  => S'

bf / S => S'
----- :: if_cons_nil
IF_CONS bt bf / [[]] : S  =>  S'

%     MAP body: Apply the body expression to each element of the list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  (list 'b) : 'A
%    iff   body :: [ 'elt : 'A -> 'b : 'A ]

body / d : S => d' : S
MAP body /  < l >  : S  =>   < l' >  : S
----- :: list_map_cons
MAP body / [[ d ; < l > ]]  : S  =>  [[ d' ; < l' > ]] : S

----- :: list_map_nil
MAP body / {} : S  =>  {} : S

%     SIZE: Get the number of elements in the list.

% :: list 'elt : 'S -> nat : 'S

SIZE / < l >  : S  =>  n : S
----- :: list_size_cons
SIZE / [[ d ; <l> ]] : S  =>  1n + n : S

----- :: list_size_nil
SIZE / {} : S  =>  0n : S

%     ITER body: Apply the body expression to each element of a list. The body sequence has access to the stack.

% :: (list 'elt) : 'A   ->  'A
%      iff body :: [ 'elt : 'A -> 'A ]

body ; ITER body / d : <l>  : S => S'
----- :: list_iter_cons
ITER body / [[ d ; <l> ]] : S  =>  S'

----- :: list_iter_nil
ITER body / {} : S  =>  S

% Local Variables:
% compile-command: "ott -colour=false michelson.ott
% End:
